<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Math vs KilleRRacing</title>
  <style>
    /* === AJUSTES GLOBALES RESPONSIVOS === */
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    html, body {
      width: 100%;
      height: 100%;
      overflow-x: hidden;
      font-family: 'Arial Black', sans-serif;
      background-color: black;
      color: white;
    }

    /* === ESCALADO GLOBAL DE FUENTES Y ESPACIOS === */
    body, input, button, h1, h2, h3, h4, p, span {
      font-size: clamp(0.9rem, 2.5vw, 1.3rem);
    }

    /* Base style for main screens (start, selection, game, results) */
    .screen {
      position: absolute;
      width: 100%;
      height: 100vh;
      display: none; /* All screens are hidden by default, JS will manage visibility */
      align-items: center;
      justify-content: flex-start;
      flex-direction: column;
      background: radial-gradient(circle at center, #111 0%, black 100%);
      z-index: 100;
      padding-top: 0;
    }

    /* === FLEXIBLE AND RESPONSIVE CONTAINERS === */
    .content-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
      width: 100%;
      max-width: 600px;
      text-align: center;
      padding: 0 20px;
      min-width: 280px;
      margin-top: 20px;
    }

    /* Animated background shared by start/selection screens */
    .background-lines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: repeating-linear-gradient(
        to bottom,
        rgba(255, 255, 255, 0.05),
        rgba(255, 255, 255, 0.05) 2px,
        transparent 2px,
        transparent 20px
      );
      animation: moveLines 10s linear infinite;
      z-index: -1;
    }

    @keyframes moveLines {
      from { transform: translateY(0); }
      to { transform: translateY(-200px); }
    }

    /* Logo container */
    .logo-container {
        position: relative;
        width: 100%;
        text-align: center;
        margin-bottom: 10px;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
    }

    /* Game logo style */
    .game-logo {
      width: 100%;
      max-width: none;
      display: block;
    }
    
    /* Dynamic Lines (fixed gradient with moving glow) */
    .dynamic-line {
      position: absolute;
      width: 100%;
      overflow: hidden;
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* White line under logo */
    .dynamic-line.white {
      height: 2px;
      background: linear-gradient(to right, transparent, white, transparent);
      bottom: 0;
      left: 0;
      z-index: 6; 
    }

    /* REMOVED: Red-yellow line in footer (replaced by canvas) */
    /* .screen > .dynamic-line.red-yellow {
      height: 4px;
      background: linear-gradient(to right, red, yellow, red);
      bottom: 50px;
      left: 0;
      z-index: 7; 
    } */

    /* Moving glow for dynamic lines */
    .dynamic-line::before {
      content: '';
      position: absolute;
      top: 0;
      height: 100%;
      transform-origin: center;
    }

    /* Specific moving light color for white line */
    .dynamic-line.white::before {
      left: -100%;
      width: 50%;
      background: rgba(255, 255, 255, 0.6);
      box-shadow: 0 0 10px white, 0 0 20px white;
      animation: moveLine 2s linear infinite;
    }
    
    /* REMOVED: Moving glow for red-yellow line (replaced by canvas) */
    /* .dynamic-line.red-yellow::before {
      left: -100%;
      width: 50%;
      background: rgba(255, 255, 0, 0.6);
      box-shadow: 0 0 10px yellow, 0 0 20px yellow;
      animation: moveLine 3s linear infinite;
    } */

    /* Keyframe for the moving glow (reused) */
    @keyframes moveLine {
      0% { left: -100%; }
      100% { left: 100%; }
    }

    /* Style for car/carabela images on name input screens and level screen */
    .name-screen-car-img {
        width: 100%;
        max-width: 200px;
        height: auto;
        display: block;
        margin: 0 auto;
        animation: imageGlow 1.5s infinite alternate; /* Apply the glow animation */
    }

    /* New style for white animated lines directly under images */
    .line-under-image {
        width: 100%;
        max-width: 200px;
        height: 2px;
        background: linear-gradient(to right, transparent, white, transparent);
        margin-top: 5px;
        margin-bottom: 15px;
        position: relative;
        overflow: hidden;
    }
    .line-under-image::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 50%;
        height: 100%;
        background: rgba(255, 255, 255, 0.6);
        box-shadow: 0 0 10px white, 0 0 20px white;
        animation: moveLine 2s linear infinite;
    }

    /* Instruction text for the user */
    .prompt-text {
      font-size: 1.2rem;
      color: #fff;
    }

    /* === RESPONSIVE INPUTS === */
    .name-input {
      width: 80%;
      max-width: 300px;
      padding: clamp(8px, 2vmin, 12px);
      font-size: clamp(1rem, 2.5vw, 1.2rem);
      border: 2px solid #0ff;
      border-radius: 10px;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      text-align: center;
      outline: none;
      transition: all 0.3s ease;
    }

    .name-input::placeholder {
      color: rgba(255, 255, 255, 0.6);
    }

    .name-input:focus {
      box-shadow: 0 0 15px #0ff;
    }

    /* === RESPONSIVE BUTTONS === */
    .start-btn, .mode-btn, .level-btn, .results-btn {
      width: clamp(120px, 70vw, 170px);
      height: auto;
      cursor: pointer;
      position: relative;
      transition: transform 0.2s ease-in-out;
      border-radius: 15px;
      overflow: hidden;
      border: none;
      background-color: transparent;
    }

    .start-btn img, .mode-btn img, .level-btn img, .results-btn img {
      width: 100%;
      display: block;
    }

    .start-btn:hover, .mode-btn:hover, .level-btn:hover, .results-btn:hover {
      transform: translateY(-5px);
    }

    /* Glow effects for buttons */
    .start-btn::before, .start-btn::after,
    .mode-btn::before, .mode-btn::after,
    .level-btn::before, .level-btn::after {
      content: '';
      position: absolute;
      top: -10px;
      left: -10px;
      right: -10px;
      bottom: -10px;
      background: linear-gradient(45deg, #0ff, #f0f, #ff0, #0ff);
      background-size: 400% 400%;
      z-index: -1;
      filter: blur(8px);
      animation: glowing 15s linear infinite;
      border-radius: 20px;
    }

    @keyframes glowing {
      0% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
      100% { background-position: 0% 50%; }
    }

    .start-btn::after, .mode-btn::after, .level-btn::after {
      filter: blur(15px);
      opacity: 0.7;
      animation-delay: -5s;
    }

    /* Footer text (original game style - now for the new canvas footer) */
    /* REMOVED .footer-text as it's replaced by #custom-footer-text and #animatedCanvas */
    /* .footer-text {
      position: absolute;
      bottom: 10px;
      font-size: 1.2rem;
      color: yellow;
      z-index: 10;
    } */

    /* Styles for button sections on menu screens */
    #mode-selection-screen .mode-buttons,
    #level-selection-screen .level-buttons {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    #mode-selection-screen h2,
    #level-selection-screen h2,
    .game-title-text {
      font-size: 1.5rem;
      color: yellow;
      text-shadow: 0 0 10px yellow;
      margin-top: 20px;
      margin-bottom: 20px;
    }

    /* New style for the subtitle on the mode selection screen */
    .mode-subtitle {
        font-size: clamp(1.1rem, 2.8vw, 1.4rem); /* Slightly smaller than main title */
        color: #0ff; /* Cyan color */
        text-shadow: 0 0 8px #0ff;
        margin-top: -10px; /* Adjust spacing with the main title */
        margin-bottom: 20px;
    }

    /* --- STYLES FOR TWO-PLAYER SCREEN (NAME INPUT) --- */
    #start-screen-for-two-players .content-wrapper.two-player-setup {
        flex-direction: row;
        flex-wrap: wrap;
        gap: 20px;
        max-width: none;
        width: 90%;
        justify-content: center;
    }

    .player-setup-column {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
        width: 45%;
        min-width: 250px;
    }

    /* SPECIFIC STYLES FOR THE MATH GAME */
    #game-screen {
        display: none;
        width: 100%;
        height: 100vh;
        position: absolute;
        top: 0;
        left: 0;
        z-index: 50;
        align-items: stretch;
        justify-content: flex-start;
        flex-direction: column;
    }

    /* Main game container for the math game */
    #contenedor-juego {
      display: flex;
      flex-direction: column;
      height: 100vh;
      width: 100%;
      margin: 0 auto;
      background-color: #3e3e3e;
      position: relative;
      justify-content: space-between;
    }

    /* Animated dividing strip (yellow segmented line) */
    #franja-divisoria {
      height: 2px;
      background: linear-gradient(to left, yellow 50%, transparent 50%);
      background-size: 200% 100%;
      animation: movimiento-linea 1s linear infinite;
    }
    /* Class to pause CSS animations */
    .paused {
        animation-play-state: paused !important;
    }

    @keyframes movimiento-linea {
      from { background-position-x: 0; }
      to { background-position-x: -200%; }
    }

    /* Operations Feedback Lights Container (now global and central) */
    #global-operations-feedback-lights-container {
        position: absolute;
        top: 0px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10; 
        display: flex; 
        flex-direction: row;
        align-items: center;
        justify-content: center;
        gap: 15px;
        background-color: transparent;
        padding: 0;
        border-radius: 0;
        border: none;
        box-shadow: none;
        width: fit-content; 
        min-width: 300px;
    }

    .operation-light {
        width: 20px;
        height: 20px;
        background-image: url('https://i.postimg.cc/43Sc42pN/L-Amarillo.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        border-radius: 50%;
        transition: background-image 0.2s ease-in-out;
        flex-shrink: 0;
    }
    .operation-light.green {
        background-image: url('https://i.postimg.cc/RhrnK3Pk/L-Verde.png'); 
    }
    .operation-light.red {
        background-image: url('https://i.postimg.cc/SRpJjBRq/L-Roja.png'); 
    }
    .operation-light.yellow {
        background-image: url('https://i.postimg.cc/43Sc42pN/L-Amarillo.png'); 
    }

    #global-operations-feedback-lights-container .lights-row {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 3px;
    }

    .global-info-display {
        display: flex;
        flex-direction: row; 
        justify-content: space-around; 
        align-items: center;
        width: auto;
        gap: 10px;
    }

    .global-info-display .info-item {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 2px;
        white-space: nowrap;
        font-size: clamp(0.8rem, 1.8vw, 1.0rem);
        color: white;
    }

    .global-info-display .info-item .icono {
        width: 25px;
        height: 25px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
    }
    .global-info-display .info-item .valor-info {
        font-weight: bold;
        color: yellow;
        font-size: clamp(1rem, 2.5vw, 1.3rem);
    }

    /* Fixed checkered flag line at the bottom of the track */
    #bottom-track-line {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 8px;
      background-image: linear-gradient(45deg, white 25%, transparent 25%, transparent 75%, white 75%),
                        linear-gradient(45deg, white 25%, transparent 25%, transparent 75%, white 75%);
      background-size: 16px 8px;
      background-position: 0 0, 8px 0;
      animation: checkered-horizontal-movement 1s linear infinite;
      z-index: 8;
    }

    @keyframes checkered-horizontal-movement {
        from { background-position: 0 0, 8px 0; }
        to { background-position: -16px 0, -8px 0; }
    }

    /* Main container for game area (gardens, borders, road) */
    #game-area-container {
      flex-grow: 1;
      display: flex;
      width: 100%;
      position: relative;
      overflow: hidden;
    }

    /* Left and right gardens - now flex items in game-area-container */
    .jardin {
      width: 10%;
      height: 100%;
      background: linear-gradient(#aed581, #558b2f);
      flex-shrink: 0;
      position: relative;
      overflow: hidden;
    }

    /* Additional yellow borders between gardens and road - also flex items */
    .borde-via {
      width: 0.5vmin;
      height: 100%;
      background-color: yellow;
      z-index: 5;
      flex-shrink: 0;
    }

    /* Player lane area - now ALWAYS single lane */
    .player-lane {
      flex-grow: 1;
      position: relative; 
      background-color: #3e3e3e;
      overflow: hidden; 
      display: block; 
    }

    /* White center line of the lane (reverted to segmented, moved top-to-bottom) */
    .player-lane .linea-central {
      position: absolute;
      left: 50%;
      top: 0;
      width: 0.8vmin;
      height: 100%;
      background: repeating-linear-gradient(
        to bottom,
        transparent,
        transparent 20px,
        white 20px,
        white 40px
      );
      animation: linea-movimiento 2s linear infinite;
      transform: translateX(-50%);
      z-index: 6;
    }

    @keyframes linea-movimiento {
      from { background-position-y: 0; }
      to { background-position-y: 80px; }
    }

    /* Central dividing line for two-player mode - ALWAYS HIDDEN */
    #central-divider {
        display: none; 
    }

    /* === RESPONSIVE GAME ELEMENTS === */
    .player-car {
      width: 10vmin;
      height: auto;
      position: absolute;
      bottom: 5vmin;
      z-index: 10;
    }

    .player-name-display {
      position: absolute;
      bottom: 1.5vmin; /* Esto se ajustará por JS */
      left: 50%;
      transform: translateX(-50%);
      color: yellow;
      font-size: clamp(0.8rem, 2.5vmin, 1.1rem);
      font-weight: bold;
      white-space: nowrap;
      z-index: 11; /* Aumentado para que esté encima del coche */
      background-color: rgba(0, 0, 0, 0.5);
      padding: 2px 8px;
      border-radius: 5px;
    }

    .suma-caida {
      position: absolute;
      color: white;
      font-size: clamp(0.75rem, 2.5vw, 1.25rem);
      font-weight: bold;
      text-decoration: underline;
      white-space: nowrap;
      z-index: 8;
      background-color: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      border-radius: 8px;
      transition: all 0.1s ease-out;
    }

    /* Style for highlighting the colliding sum */
    .suma-caida.colliding-highlight {
      transform: scale(1.15);
      border: 3px solid yellow;
      box-shadow: 0 0 10px yellow, 0 0 20px yellow;
      z-index: 101;
    }

    /* Animation for correct sum explosions */
    @keyframes explode {
      0% { transform: scale(1) translate(-50%, 0); opacity: 1; filter: brightness(1); }
      50% { transform: scale(1.5) translate(-50%, 0); opacity: 0.8; filter: brightness(2); }
      100% { transform: scale(0) translate(-50%, 0); opacity: 0; filter: brightness(0); }
    }

    .suma-caida.explode {
      animation: explode 0.5s ease-out forwards;
    }

    /* Animation and style for incorrect answer feedback */
    .suma-caida.incorrect-answer-feedback {
      color: red !important;
      border: 2px solid red;
      animation: flashRed 0.5s 2;
    }

    @keyframes flashRed {
        0%, 100% { background-color: rgba(0, 0, 0, 0.5); }
        50% { background-color: rgba(255, 0, 0, 0.7); }
    }

    /* Style for Pit element (wrench icon) */
    .pit {
        position: absolute;
        width: 25vmin; /* Ajustado de 6vmin a 25vmin */
        height: 25vmin; /* Ajustado de 6vmin a 25vmin */
        background-image: url('https://i.postimg.cc/0N8208xH/Pits.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        z-index: 8;
    }

    /* Style for Slowdown Strip */
    .slowdown-strip {
        position: absolute;
        width: 25vmin; /* Ajustado de 20vmin a 25vmin */
        height: 15vmin; /* Ajustado para mantener proporción visual (aprox) */
        background-image: url('https://i.postimg.cc/KYx2byHd/Barreras.png');
        background-size: contain; 
        background-repeat: no-repeat; 
        background-position: center;
        z-index: 7;
    }
    
    /* Style for Hole element */
    .hueco {
        position: absolute;
        width: 35vmin; /* Ajustado de 8vmin a 35vmin */
        height: 35vmin; /* Ajustado de 8vmin a 35vmin */
        background-image: url('https://i.postimg.cc/pd05dcb1/Hueco.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        z-index: 8;
    }

    /* Style for KilleRacing element (on track) */
    .kille-racing {
        position: absolute;
        width: 9.84375vmin; /* REDUCIDO EN UN 25% ADICIONAL (13.125 * 0.75) */
        height: 9.84375vmin; /* REDUCIDO EN UN 25% ADICIONAL (13.125 * 0.75) */
        z-index: 12;
        background-image: url('https://i.postimg.cc/gcNB342d/Carabela.png'); /* IMAGEN DE CARABELA */
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        transform: scaleX(-1); /* Inicialmente volteado para que mire a la izquierda al entrar por la derecha */
    }

    /* Style for KilleRRacing in attack mode (over the sum) */
    .kille-racing.attack-mode {
        position: absolute;
        width: 15vmin; /* Tamaño ajustado para visibilidad en ataque */
        height: 15vmin;
        background-image: url('https://i.postimg.cc/gcNB342d/Carabela.png');
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        z-index: 102; /* Para asegurar que esté sobre la operación */
        transform: none; /* No volteado en modo ataque, mira hacia abajo */
    }

    /* Style for temporary collision feedback message */
    .collision-feedback-message {
        position: absolute;
        font-size: clamp(1rem, 3vw, 1.5rem);
        font-weight: bold;
        color: red;
        text-shadow: 0 0 10px black;
        opacity: 0;
        animation: fadeOutUp 1.5s ease-out forwards;
        z-index: 100;
    }

    @keyframes fadeOutUp {
        0% { opacity: 1; transform: translateY(0); }
        100% { opacity: 0; transform: translateY(-50px); }
    }

    /* Trees falling in gardens - NOW PERCENTAGE OF PARENT WIDTH */
    .arbol {
      position: absolute;
      width: 80%;
      height: auto;
      animation: tree-fall 10s linear infinite;
    }
    /* Specific animation for tree fall if needed (can be controlled by JS) */
    @keyframes tree-fall {
        from { transform: translateY(-100%); }
        to { transform: translateY(100vh); }
    }

    /* Container for the entire control area (input strip + directional pad) */
    .game-controls-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0;
        gap: 0;
        background-color: black;
        box-shadow: none;
    }

    /* Class for visual dimming and disabling interaction for control strips */
    .player-input-strip.inactive-controls,
    .unified-controls-row.inactive-controls {
        opacity: 0.2;
        pointer-events: none;
        transition: opacity 0.3s ease-in-out;
    }

    /* Input strip (top of two control strips) */
    .player-input-strip {
        height: 12.5vh;
        display: grid;
        grid-template-columns: 1fr 25% 1fr;
        align-items: center;
        justify-items: center;
        width: 100%;
        box-sizing: border-box;
        background-color: black;
        border: none;
        padding: 0;
        gap: 0;
        z-index: 100;
    }

    /* Adjustments for answer box size and buttons for easier touch */
    .caja-respuesta {
      padding: clamp(8px, 2.5vmin, 12px);
      font-size: clamp(0.9rem, 2vw, 1.1rem);
      max-width: 100%;
      height: 50%;
      border: 2px solid #0ff;
      border-radius: 10px;
      background-color: rgba(255, 255, 255, 0.1);
      color: white;
      text-align: left; /* Default behavior: Left-to-right */
      outline: none;
      transition: all 0.3s ease;
      box-sizing: border-box;
    }
    .caja-respuesta.rtl-input {
        direction: rtl;
        text-align: right;
    }
    .caja-respuesta::placeholder {
        color: rgba(255, 255, 255, 0.6);
    }
    .caja-respuesta:focus {
        box-shadow: 0 0 15px #0ff;
    }

    .boton-reset, .boton-enter {
      width: clamp(80px, 18vw, 120px);
      height: 50%;
      background-size: contain;
      background-position: center;
      background-repeat: no-repeat;
      background-color: transparent; 
      border: none;
      border-radius: 0;
      cursor: pointer;
      transition: none;
      transform: none;
    }

    .boton-reset::before, .boton-reset::after,
    .boton-enter::before, .boton-enter::after {
      content: none;
    }
    .boton-reset:hover, .boton-enter:hover {
        transform: none;
    }

    .boton-reset {
      background-image: url('https://i.postimg.cc/GtfXVb2r/Bt-Reset2.png');
    }

    .boton-enter {
      background-image: url('https://i.postimg.cc/nhbkDR9d/Bt-Play2.png');
    }

    /* Champion text style */
    .campeon-text {
      font-size: 1.5rem;
      color: yellow;
      text-shadow: 0 0 10px yellow, 0 0 20px yellow, 0 0 30px yellow;
      margin-top: 10px;
      animation: pulsateGlow 1.5s infinite alternate;
      display: inline-block;
    }

    @keyframes pulsateGlow {
      from { text-shadow: 0 0 10px yellow, 0 0 20px yellow; }
      to { text-shadow: 0 0 15px yellow, 0 0 25px yellow, 0 0 35px yellow; }
    }
    
    /* New style for blinking text */
    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0; }
    }

    .blinking-text {
      animation: blink 0.3s steps(1, end) infinite; /* 300ms duration, step-end for sharp blink */
    }

    /* New style for image glow */
    @keyframes imageGlow {
      0% { filter: drop-shadow(0 0 5px yellow) drop-shadow(0 0 10px yellow); }
      50% { filter: drop-shadow(0 0 8px yellow) drop-shadow(0 0 15px yellow); }
      100% { filter: drop-shadow(0 0 5px yellow) drop-shadow(0 0 10px yellow); }
    }

    .pulsating-image-glow {
      animation: imageGlow 1.5s infinite alternate;
    }

    /* --- FINAL RESULTS SCREEN STYLES --- */
    #results-screen {
        display: none;
        justify-content: flex-start;
        align-items: center;
        flex-direction: column;
        padding: 20px;
        background: radial-gradient(circle at center, #111 0%, black 100%);
        position: relative;
    }

    #results-screen .results-content-wrapper {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        width: 100%;
        max-width: 1200px;
        margin-top: 50px;
        margin-bottom: 0;
        flex-grow: 1;
        justify-content: center;
    }

    #results-screen .solo-result-panel {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 15px;
        padding: 20px;
        background-color: rgba(0, 0, 0, 0.7);
        border-radius: 15px;
        position: relative;
    }

    #results-screen .solo-result-panel img {
        max-width: 100px;
        height: auto;
        display: block;
        margin: 0 auto;
    }

    /* Specific styling for the proficiency score */
    .proficiency-score-display {
        font-size: clamp(1.8rem, 5vw, 2.5rem); /* Larger font size */
        font-weight: bold;
        color: yellow;
        text-shadow: 0 0 10px yellow, 0 0 20px yellow;
        margin-top: 15px;
        margin-bottom: 10px;
    }

    /* Container for stats in column */
    .results-stats-column {
        display: flex;
        flex-direction: column;
        align-items: flex-start; /* Align items to the start for labels */
        gap: 5px;
        width: 100%;
        max-width: 250px; /* Adjust as needed for column width */
        margin-top: 10px;
    }

    /* Individual stat row */
    .results-stat-row {
        display: flex;
        justify-content: space-between; /* Space between label and value */
        width: 100%;
        align-items: center;
    }

    /* Small white text for stats labels */
    .results-stats-label {
        font-size: clamp(0.9rem, 2.2vw, 1.1rem);
        color: white;
        font-weight: normal;
        text-align: left;
        flex-shrink: 0; /* Prevent label from shrinking */
    }

    /* Bold white text for stats values */
    .results-stats-value {
        font-size: clamp(1rem, 2.5vw, 1.3rem);
        color: white;
        font-weight: bold;
        text-align: right;
        flex-grow: 1; /* Allow value to take remaining space */
    }


    /* New line styles for results screen */
    .results-name-line {
        width: 80%;
        height: 2px;
        background: linear-gradient(to right, transparent, white, transparent);
        position: relative;
        overflow: hidden;
        margin-top: -5px;
        margin-bottom: 15px;
    }
    .results-name-line::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 50%;
        height: 100%;
        background: rgba(255, 255, 255, 0.6);
        box-shadow: 0 0 10px white, 0 0 20px white;
        animation: moveLine 2s linear infinite;
    }

    .results-reset-line {
        width: 90%;
        height: 3px;
        background: linear-gradient(to right, transparent, orange, transparent);
        position: relative;
        overflow: hidden;
        margin-top: 20px;
        margin-bottom: 10px;
    }
    .results-reset-line::before {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 50%;
        height: 100%;
        background: rgba(255, 165, 0, 0.6);
        box-shadow: 0 0 10px orange, 0 0 20px orange;
        animation: moveLine 2.5s linear infinite;
    }

    /* New table style for two players results */
    .results-table {
        width: 95%;
        max-width: 900px;
        border-collapse: collapse;
        margin-top: 20px;
        color: white;
        background-color: rgba(0, 0, 0, 0.8);
        border-radius: 15px;
        overflow: hidden;
        box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
    }

    .results-table th, .results-table td {
        padding: 15px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
        vertical-align: middle;
    }

    .results-table th {
        background-color: #0ff;
        color: black;
        font-size: clamp(1rem, 2.5vw, 1.3rem);
        font-weight: bold;
        text-transform: uppercase;
    }
    /* First and last child for border radius on header */
    .results-table th:first-child { border-top-left-radius: 15px; }
    .results-table th:last-child { border-top-right-radius: 15px; }

    .results-table tbody tr:nth-child(odd) {
        background-color: rgba(0, 0, 0, 0.6);
    }

    .results-table tbody tr:nth-child(even) {
        background-color: rgba(0, 0, 0, 0.7);
    }

    /* Specific cell styles for content alignment */
    .results-table .player-name-cell h3 {
        font-size: clamp(1.2rem, 3vw, 1.5rem);
        color: yellow;
        text-shadow: 0 0 8px yellow;
        margin-bottom: 5px;
    }

    .results-table .results-car-image {
        max-width: 60px;
        height: auto;
        display: block;
        margin: 5px auto;
    }

    .results-table .results-trophy-image {
        max-width: 40px;
        height: auto;
        display: block;
        margin: 10px auto 0;
    }
    .results-table .gold-trophy-image {
        filter: drop-shadow(0 0 5px gold) drop-shadow(0 0 10px gold);
    }
    .results-table .silver-trophy-image {
        filter: drop-shadow(0 0 5px silver) drop-shadow(0 0 10px silver);
    }

    /* Smaller labels as requested */
    .results-table .label-small {
        font-size: clamp(0.8rem, 2vw, 1.1rem);
        color: #ddd;
        font-weight: normal;
        display: inline-block;
        margin-right: 5px;
    }
    .results-table .value {
        font-size: clamp(0.9rem, 2.2vw, 1.2rem);
        color: white;
        font-weight: bold;
    }

    /* Single reset button for two players results */
    #results-screen .results-return-button {
        position: static;
        margin-top: 20px;
        margin-bottom: 0;
        margin-left: auto;
        margin-right: auto;
    }

    /* === ADJUSTMENTS FOR VERY SMALL SCREENS === */
    @media screen and (max-width: 360px) {
      /* REMOVED .footer-text adjustments as it's replaced by #custom-footer-text */
      /* .footer-text {
        font-size: 0.8rem;
      } */
    }

    /* === ORIENTATION ADJUSTMENTS === */
    @media (orientation: portrait), (max-width: 768px) {
      .screen {
        flex-direction: column;
      }
      /* Stack table columns on very small screens or portrait */
      .results-table, .results-table tbody, .results-table tr, .results-table th, .results-table td {
        display: block;
        width: 100%;
      }
      .results-table thead {
        display: none;
      }
      .results-table tr {
        margin-bottom: 15px;
        border-bottom: 3px solid #0ff;
        border-radius: 15px;
        overflow: hidden;
      }
      .results-table td {
        border: none;
        text-align: left;
        padding-left: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }
      .results-table td:last-child {
        border-bottom: none;
      }
      .results-table .player-name-cell,
      .results-table .player-score-cell,
      .results-table .player-performance-cell {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        text-align: center;
      }
      .results-table .player-name-cell h3 {
        width: 100%;
        margin-bottom: 0;
      }
      .results-table .player-score-cell,
      .results-table .player-performance-cell {
        flex-direction: row;
        justify-content: center;
        gap: 10px;
        padding-top: 5px;
        padding-bottom: 5px;
      }
      .results-table .label-small,
      .results-table .value {
        font-size: clamp(0.9rem, 2.5vw, 1.2rem);
      }
      .results-table .player-score-cell .label-small,
      .results-table .player-performance-cell .label-small {
        order: 1;
      }
      .results-table .player-score-cell .value,
      .results-table .player-performance-cell .value {
        order: 2;
      }

      /* Specific adjustments for images within the stacked cells */
      .results-table .player-name-cell img,
      .results-table .player-score-cell img {
        margin: 5px auto;
      }
    }

    /* Main container for the entire control area (input strip + directional pad) */
    .game-controls-area {
        display: flex;
        flex-direction: column;
        align-items: center;
        width: 100%;
        padding: 0;
        gap: 0;
        background-color: black;
        box-shadow: none;
    }

    /* Class for visual dimming and disabling interaction for control strips */
    .player-input-strip.inactive-controls,
    .unified-controls-row.inactive-controls {
        opacity: 0.2;
        pointer-events: none;
        transition: opacity 0.3s ease-in-out;
    }

    /* Input strip (top of two) */
    .player-input-strip {
        height: 12.5vh;
        display: grid;
        grid-template-columns: 1fr 25% 1fr;
        align-items: center;
        justify-items: center;
        width: 100%;
        box-sizing: border-box;
        background-color: black;
        border: none;
        padding: 0;
        gap: 0;
        z-index: 100;
    }

    /* Directional buttons strip (lower) */
    .unified-controls-row {
        height: 12.5vh;
        width: 100%;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 0;
        background-color: black;
        border: none;
        box-shadow: none;
        z-index: 100;
    }

    /* Internal grid container for directional buttons */
    .unified-controls-container {
        height: 100%;
        width: 100%;
        background-color: transparent;
        background-image: none;
        background-size: 100% 100%;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        gap: 0;
        align-items: center;
        justify-items: center;
        border: none;
    }

    .control-boton {
        background-color: transparent; 
        border: none; 
        border-radius: 0; 
        background-size: 100% 100%; 
        background-repeat: no-repeat;
        background-position: center;
        width: 100%; 
        height: 100%;
        cursor: pointer;
        min-width: 60px; 
        min-height: 60px; 
        box-sizing: border-box; 
        opacity: 1;
        transition: none;
        transform: none;
    }

    /* Grid area assignment for each button with new images */
    .control-izquierda {
        grid-column: 1;
        grid-row: 1 / span 2;
        background-image: url('https://i.postimg.cc/X71FtCG0/2-Bt-Izquierda.png');
    }

    .control-arriba {
        grid-column: 2;
        grid-row: 1;
        background-image: url('https://i.postimg.cc/kG9FXPq3/3-Bt-arriba.png');
    }

    .control-abajo {
        grid-column: 2;
        grid-row: 2;
        background-image: url('https://i.postimg.cc/mgh3rwfD/3-Bt-abajo.png');
    }

    .control-derecha {
        grid-column: 3;
        grid-row: 1 / span 2;
        background-image: url('https://i.postimg.cc/j2sPY64R/1-Bt-Derecha.png');
    }

    /* Global game overlay for messages */
    #game-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.7);
        z-index: 99;
        display: none;
    }

    /* Styles for the new animated lines canvas */
    .animated-canvas-footer { /* New class for all footer canvases */
        position: fixed; /* Changed to fixed */
        bottom: 30px; /* Adjusted position above text */
        left: 0;
        width: 100%;
        height: 16px; /* 8 lines * 2px height each = 16px total height */
        display: block;
        z-index: 101; /* Set higher than .screen to be visible */
        pointer-events: none; /* Allow clicks to pass through to elements below */
    }

    /* Styles for the custom footer text */
    .custom-footer-text-style { /* New class for all footer texts */
        position: fixed; /* Changed to fixed */
        bottom: 10px; /* Positioned below the canvas lines */
        left: 50%;
        transform: translateX(-50%);
        color: yellow;
        font-family: 'cursive', sans-serif;
        font-size: 1.2rem;
        white-space: nowrap;
        z-index: 101; /* Set higher than .screen to be visible */
        font-style: italic; /* Ensure italic inclination */
    }

  </style>
</head>
<body>

  <!-- SCREEN 1: MODE SELECTION SCREEN -->
  <div id="mode-selection-screen" class="screen">
    <div class="background-lines"></div>
    <div class="logo-container">
        <img src="https://i.postimg.cc/Rhs1fCHK/TITULO-MATHRACING-1-BETA.png" alt="Math vs KilleRRacing Logo" class="game-logo" />
        <div class="dynamic-line white"></div>
    </div>
    <div class="content-wrapper">
      <h2>¡Vamos a Jugar!</h2>
      <h3 class="mode-subtitle">Reto de las Sumas</h3> <!-- Nuevo título aquí -->
      <div class="mode-buttons">
        <div class="mode-btn" onclick="selectMode('solo')">
          <img src="https://i.postimg.cc/3xJ9d19D/Bt-Solitario.png" alt="Modo Solitario" />
        </div>
        <div class="mode-btn two-players-btn" onclick="selectMode('twoPlayers')">
          <img src="https://i.postimg.cc/1txpcr0B/Bt-Pareja.png" alt="Modo En Pareja" />
        </div>
      </div>
    </div>
    <!-- New animated canvas for footer lines -->
    <canvas id="animatedCanvas" class="animated-canvas-footer"></canvas>
    <!-- New custom footer text -->
    <div id="custom-footer-text" class="custom-footer-text-style">Profesor: Wilman Corcho</div>
  </div>

  <!-- SCREEN 2: LEVEL SELECTION SCREEN -->
  <div id="level-selection-screen" class="screen">
    <div class="background-lines"></div>
    <div class="content-wrapper">
      <img src="https://i.postimg.cc/YCpLLPfz/IMG-Carro-1.png" alt="Carro para selección de nivel" class="name-screen-car-img pulsating-image-glow" />
      <div class="line-under-image"></div>
      <h2>Nivel</h2>
      <div class="level-buttons">
        <div class="level-btn" onclick="selectLevel('principiante')">
          <img src="https://i.postimg.cc/13swvrd5/Bt-Principiante.png" alt="Nivel Principiante" />
        </div>
        <div class="level-btn" onclick="selectLevel('novato')">
          <img src="https://i.postimg.cc/htsx67F8/Bt-Novato.png" alt="Nivel Novato" />
        </div>
        <div class="level-btn" onclick="selectLevel('experto')">
          <img src="https://i.postimg.cc/VNHtLQkd/Bt-Experto.png" alt="Nivel Experto" />
        </div>
      </div>
    </div>
    <!-- New animated canvas for footer lines -->
    <canvas id="animatedCanvasLevel" class="animated-canvas-footer"></canvas>
    <!-- New custom footer text -->
    <div id="custom-footer-textLevel" class="custom-footer-text-style">Profesor: Wilman Corcho</div>
  </div>

  <!-- NAME INPUT SCREEN (FOR SOLO GAME) -->
  <div id="start-screen-for-name" class="screen">
    <div class="background-lines"></div>
    <div class="content-wrapper">
      <img src="https://i.postimg.cc/gJ3B0X2t/IMG-Carabela-1.png" alt="Carabela 1" class="name-screen-car-img pulsating-image-glow" />
      <div class="line-under-image"></div>

      <div class="prompt-text">Escribe tu nombre</div>

      <input type="text" class="name-input" placeholder="Tu nombre..." id="player-name" tabindex="0" autocomplete="off" />

      <div class="start-btn" onclick="startGame()">
        <img src="https://i.postimg.cc/3N20BkCv/Bt-Inicio.png" alt="Iniciar Juego" />
      </div>
    </div>
    <!-- New animated canvas for footer lines -->
    <canvas id="animatedCanvasSoloName" class="animated-canvas-footer"></canvas>
    <!-- New custom footer text -->
    <div id="custom-footer-textSoloName" class="custom-footer-text-style">Profesor: Wilman Corcho</div>
  </div>

  <!-- NAME INPUT SCREEN (FOR TWO PLAYERS) -->
  <div id="start-screen-for-two-players" class="screen">
    <div class="background-lines"></div>
    <div class="content-wrapper two-player-setup">
      <div class="player-setup-column">
        <img src="https://i.postimg.cc/gJ3B0X2t/IMG-Carabela-1.png" alt="Carabela Jugador 1" class="name-screen-car-img pulsating-image-glow" />
        <div class="line-under-image"></div>
        <div class="prompt-text">Jugador 1: Escribe tu nombre</div>
        <input type="text" class="name-input" placeholder="Nombre Jugador 1..." id="player1-name-input" tabindex="0" autocomplete="off" />
      </div>
      <div class="player-setup-column">
        <img src="https://i.postimg.cc/Qx5xNJ2k/IMG-Carabela-2.png" alt="Carabela Jugador 2" class="name-screen-car-img pulsating-image-glow" />
        <div class="line-under-image"></div>
        <div class="prompt-text">Jugador 2: Escribe tu nombre</div>
        <input type="text" class="name-input" placeholder="Nombre Jugador 2..." id="player2-name-input" tabindex="0" autocomplete="off" />
      </div>
      <div class="start-btn" onclick="startGameTwoPlayers()">
        <img src="https://i.postimg.cc/3N20BkCv/Bt-Inicio.png" alt="Iniciar Juego" />
      </div>
    </div>
    <!-- New animated canvas for footer lines -->
    <canvas id="animatedCanvasTwoPlayers" class="animated-canvas-footer"></canvas>
    <!-- New custom footer text -->
    <div id="custom-footer-textTwoPlayers" class="custom-footer-text-style">Profesor: Wilman Corcho</div>
  </div>

  <!-- MATH GAME PAGE -->
  <div id="game-screen">
    <div id="contenedor-juego">

      <!-- ANIMATED DIVIDING STRIP (yellow segmented line) -->
      <div id="franja-divisoria"></div>
      
      <!-- Operations Feedback Lights Container (GLOBAL and CENTRAL) -->
      <div id="global-operations-feedback-lights-container">
          <div class="lights-row" id="operations-lightbulbs">
              <!-- Lights will be appended by JS -->
          </div>
          <div class="global-info-display">
                <div class="info-item">
                    <div class="icono" style="background-image: url('https://i.postimg.cc/cLD8BkzR/I-Moneda.png');"></div>
                    <span class="valor-info" id="global-puntuacion">000</span>
                </div>
                <div class="info-item">
                    <div class="icono" style="background-image: url('https://i.postimg.cc/kg7kjsYf/Llaves.png');"></div>
                    <span class="valor-info" id="global-puntos-pits">000</span>
                </div>
                <div class="info-item">
                    <div class="icono" style="background-image: url('https://i.postimg.cc/KcsVCmgw/Reloj.png');"></div>
                    <span class="valor-info" id="global-tiempo">00:00</span>
                </div>
          </div>
      </div>

      <!-- Main container for game area (gardens, borders, road) -->
      <div id="game-area-container">
        <!-- CHECKERED FLAG LINE AT THE BOTTOM OF THE TRACK -->
        <div id="bottom-track-line"></div>
        <!-- GARDENS (Side columns) -->
        <div id="jardin-izquierdo" class="jardin"></div>
        <!-- ADDITIONAL YELLOW BORDERS between gardens and road -->
        <div id="borde-izquierdo-via" class="borde-via"></div>
        
        <!-- Player Lane (now only one visible lane) -->
        <div id="player1-lane" class="player-lane">
          <!-- Central segmented line -->
          <div class="linea-central"></div>
          <img id="player-car-display" class="player-car" src="" alt="Coche del jugador"/>
          <div id="player-name-display" class="player-name-display"></div>
          <!-- KilleRacing will be added here dynamically -->
        </div>

        <!-- ADDITIONAL YELLOW BORDERS between gardens and road -->
        <div id="borde-derecho-via" class="borde-via"></div>
        <div id="jardin-derecho" class="jardin"></div>
      </div>
      
      <!-- NEW: Global game overlay for messages -->
      <div id="game-overlay"></div>

      <!-- NEW: Single container for the entire control area (input strip + directional pad) -->
      <div id="game-controls-area" class="game-controls-area">
          <!-- Input strip (top of two) -->
          <div class="player-input-strip" id="player-input-strip">
              <button id="boton-reset-player1" class="boton-reset" tabindex="0"></button>
              <input type="text" id="caja-respuesta-player1" class="caja-respuesta" placeholder="Responde aquí..." tabindex="0" />
              <button id="boton-enter-player1" class="boton-enter" tabindex="0"></button>
          </div>

          <!-- Directional buttons strip (lower) -->
          <div class="unified-controls-row" id="unified-controls-row">
              <div class="unified-controls-container">
                  <button id="btn-izquierda-player1" class="control-boton control-izquierda" tabindex="0"></button>
                  <button id="btn-arriba-player1" class="control-boton control-arriba" tabindex="0"></button>
                  <button id="btn-abajo-player1" class="control-boton control-abajo" tabindex="0"></button>
                  <button id="btn-derecha-player1" class="control-boton control-derecha" tabindex="0"></button>
              </div>
          </div>
      </div>

    </div>
  </div>

  <!-- FINAL RESULTS SCREEN -->
  <div id="results-screen" class="screen">
      <div class="background-lines"></div>
      <div class="results-content-wrapper" id="dynamic-results-content">
      </div>
  </div>


  <script>
    // Script del juego 'Math vs KilleRRacing' iniciado.

    // --- VARIABLES DE ESTADO GLOBAL Y BANDERAS DEL JUEGO ---
    // Este bloque centraliza las variables clave para el control del juego.

    /**
     * @property {number} seconds - Contador de segundos transcurridos en el juego.
     */
    let seconds = 0;

    /**
     * @property {boolean} gamePaused - Indica si el juego está en estado de pausa (true) o activo (false).
     * Esto ocurre durante colisiones, mensajes en pantalla, etc.
     */
    let gamePaused = false;

    /**
     * @property {number} gameSpeedMultiplier - Multiplicador que ajusta la velocidad general de todos los elementos en movimiento.
     */
    let gameSpeedMultiplier = 1.0;

    // --- Banderas y contadores para el efecto de Barrera ---
    /**
     * @property {boolean} isBarrierEffectActive - True si el efecto de "Pista Fácil" (Barrera) está activo.
     * Durante este efecto, solo se generan sumas sencillas.
     */
    let isBarrierEffectActive = false;
    /**
     * @property {number} barrierSimpleSumsCounter - Contador de sumas sencillas restantes a generar
     * durante el efecto de la Barrera.
     */
    let barrierSimpleSumsCounter = 0;
    /**
     * @property {number} barrierEffectStartTime - Marca de tiempo (Date.now()) cuando inició el efecto de Barrera.
     */
    let barrierEffectStartTime = 0;
    /**
     * @property {number} barrierEffectDuration - Duración total (en milisegundos) del efecto de Barrera.
     */
    let barrierEffectDuration = 0;
    /**
     * @property {boolean} barrierTimeElapsed - Bandera que indica si el tiempo mínimo/máximo del efecto de Barrera ha transcurrido.
     */
    let barrierTimeElapsed = false;

    // --- Variables para la gestión de carriles ocupados por objetos (Pit, Hueco, Barrera) ---
    /**
     * @property {object} laneOccupancy - Objeto que indica si el sub-carril izquierdo o derecho
     * dentro de la vía principal está ocupado por un objeto especial.
     * @property {boolean} laneOccupancy.left - True si el sub-carril izquierdo está ocupado.
     * @property {boolean} laneOccupancy.right - True si el sub-carril derecho está ocupado.
     * KilleRRacing ocupa ambos carriles cuando está en pantalla.
     */
    let laneOccupancy = { left: false, right: false };

    // --- Variables de control para la generación y reaparición de objetos especiales (basado en tiempo) ---
    /**
     * @property {number} lastBarrierAppearanceTime - Tiempo (en segundos del juego) de la última aparición de una Barrera.
     */
    let lastBarrierAppearanceTime = -Infinity;
    /**
     * @property {number} lastHoleAppearanceTime - Tiempo (en segundos del juego) de la última aparición de un Hueco.
     */
    let lastHoleAppearanceTime = -Infinity;
    /**
     * @property {number} lastPitAppearanceTime - Tiempo (en segundos del juego) de la última aparición de un Pit.
     */
    let lastPitAppearanceTime = -Infinity;
    /**
     * @property {number} lastKillerRacerAppearanceTime - Tiempo (en segundos del juego) de la última aparición de KilleRRacing.
     * Usado para el cooldown en nivel principiante.
     */
    let lastKillerRacerAppearanceTime = -Infinity;

    // --- Variables específicas de KilleRRacing ---
    /**
     * @property {HTMLElement|null} killeRacingInstance - Referencia al elemento DOM de KilleRRacing cuando está activo en pantalla.
     */
    let killeRacingInstance = null;
    /**
     * @property {string} killeRacingHorizontalDirection - Dirección horizontal actual de KilleRRacing ('left' o 'right').
     */
    let killeRacingHorizontalDirection = 'left';
    /**
     * @property {number} operationsAnsweredSinceLastKilleRacing - Contador de operaciones respondidas desde la última aparición de KilleRRacing.
     * Se usa para determinar su aparición en niveles Novato y Experto.
     */
    let operationsAnsweredSinceLastKilleRacing = 0;
    /**
     * @property {number} KILLER_RACER_BASE_SPEED - Velocidad base de movimiento de KilleRRacing.
     */
    const KILLER_RACER_BASE_SPEED = 1.1; // Velocidad base de caída/horizontal de KilleRRacing
    /**
     * @property {number} KILLER_RACER_ACCELERATED_SPEED_MULTIPLIER - Multiplicador para la velocidad acelerada de KilleRRacing.
     */
    const KILLER_RACER_ACCELERATED_SPEED_MULTIPLIER = 1.8;
    /**
     * @property {object} killeRacingState - Objeto de estado para gestionar el comportamiento complejo de KilleRRacing.
     * @property {boolean} killeRacingState.isAccelerating - True si KilleRRacing está actualmente en su fase acelerada de movimiento.
     * @property {string} killeRacingState.initialDirection - Dirección inicial de entrada de KilleRRacing ('left' o 'right').
     * @property {number} killeRacingState.midLanePoint - Punto horizontal en píxeles donde KilleRRacing cambia de velocidad en niveles avanzados.
     * @property {string} killeRacingState.initialSpeedType - Tipo de velocidad inicial de KilleRRacing ('normal' o 'accelerated').
     * @property {number} killeRacingState.currentSpeed - Velocidad actual de KilleRRacing para el frame.
     * @property {boolean} killeRacingState.speedChangedMidLane - Bandera para controlar si la velocidad ya cambió al cruzar el punto medio.
     */
    let killeRacingState = {
        isAccelerating: false,
        initialDirection: null,
        midLanePoint: 0,
        initialSpeedType: null,
        currentSpeed: KILLER_RACER_BASE_SPEED, // Se inicializa con la velocidad base.
        speedChangedMidLane: false // Nueva bandera para controlar el cambio de velocidad a mitad de carril.
    };

    // --- NUEVAS VARIABLES PARA EL ATAQUE DE KILLERRACING SOBRE LA OPERACIÓN ---
    let isKillerRacingAttacking = false;
    let killeRacingAttackAnimId = null;
    let killerRacingCurrentSpeed = 0;
    let killeRacingTargetY = 0;
    let killeRacingAttackInstance = null; // Elemento de KilleRRacing en modo ataque
    let killeRacingAttackStartTime = 0; // Tiempo de inicio del ataque de KilleRRacing.

    // Constantes para la nueva mecánica de KilleRRacing en modo ataque
    const KILLER_RACING_ATTACK_START_Y = -100; // Posición inicial Y (fuera de la vista, arriba, en vmin)
    const TWO_PLAYER_GENEROUS_TIME_ADDITION_MS = 1000; // 1 segundo adicional para modo parejas (se sumará aleatoriamente 1 o 2 segundos)


    // --- Variables de control para el sistema de fases (equilibrio sumas/objetos) ---
    /**
     * @property {string} currentPhase - La fase actual de generación del juego ('sums' o 'objects').
     * Determina si se generan sumas matemáticas o un objeto especial (Pit, Hueco, Barrera).
     */
    let currentPhase = 'sums';
    /**
     * @property {number} sumsCountForCurrentPhase - Número de sumas que deben generarse en la fase actual de 'sums'
     * antes de pasar a la fase de 'objects'.
     */
    let sumsCountForCurrentPhase = 0;
    /**
     * @property {number} currentSumsGeneratedInPhase - Contador de sumas ya generadas en la fase actual de 'sums'.
     */
    let currentSumsGeneratedInPhase = 0;
    /**
     * @property {boolean} objectGeneratedThisPhase - True si un objeto especial (no KilleRRacing) ya se generó en la fase actual de 'objects'.
     */
    let objectGeneratedThisPhase = false;


    // --- Intervalos y RequestAnimationFrame IDs ---
    let timeInterval; // ID para el temporador principal del juego (setInterval)
    let createTreesInterval; // ID para el intervalo de creación de árboles (setInterval)
    let createSumInterval; // ID para el intervalo de creación de sumas regulares (setInterval)
    let generateSimpleSumsInterval; // ID para el intervalo de creación de sumas sencillas (efecto Barrera)
    let gameLoopId = null; // ID para el bucle principal del juego (requestAnimationFrame)
    let killeRacingAnimId = null; // ID para la animación de KilleRRacing (requestAnimationFrame)
    const activeRAFAnimations = new Map(); // Mapa para almacenar IDs de animaciones requestAnimationFrame activas

    // --- Variables de estado de la interfaz de usuario ---
    let currentCollidingSum = null; // Referencia a la suma con la que el jugador ha colisionado.
    let gameMode = 'solo'; // Modo de juego actual ('solo' o 'twoPlayers')
    let currentLevel = 'principiante'; // Nivel de dificultad actual ('principiante', 'novato', 'experto')
    let gameRound = 0; // Turno actual en modo de dos jugadores (0 para Jugador 1, 1 para Jugador 2)


    // --- LÍMITES Y CONSTANTES DEL JUEGO (MODULARIZADOS POR NIVEL/FACTOR) ---
    let currentMaxAnsweredSums = 0; // Se establecerá según la selección de nivel y afectará las "luces".

    const BASE_ROAD_WIDTH = 960; // Ancho base de la vía para cálculos de escalado.
    const BASE_ROAD_HEIGHT = 540; // Altura base de la vía para cálculos de escalado.
    const INITIAL_CAR_MOVEMENT_SPEED_BASE = 4; // Velocidad base de movimiento horizontal del coche.
    const INITIAL_SUM_HORIZONTAL_SPEED_BASE = 1; // Velocidad base de movimiento horizontal de las sumas.
    const INITIAL_FALLING_OBJECT_SPEED_BASE = 2; // Velocidad base de caída para árboles, pits, barreras, huecos.
    const INITIAL_TREE_CREATION_INTERVAL_BASE = 500; // Intervalo base para la creación de árboles.
    const ANSWERS_TO_INCREASE_SPEED = 2; // Cantidad de respuestas correctas para aumentar la velocidad.
    const MAX_LIVES = 3; // Número máximo de vidas (actualmente no implementado activamente).

    const MIN_CAR_VERTICAL_POS_REM = 20; // Posición vertical mínima del coche 'bottom' en vmin (más arriba).
    const MAX_CAR_VERTICAL_POS_REM = 5; // Posición vertical máxima del coche 'bottom' en vmin (más abajo).
    const CAR_VERTICAL_SPEED_STEP_REM = 0.5; // Qué tan rápido se mueve el coche verticalmente al acelerar/desacelerar.

    const MIN_GAME_SPEED_MULTIPLIER = 0.5; // Multiplicador mínimo de velocidad del juego.
    const MAX_GAME_SPEED_MULTIPLIER = 2.0; // Multiplicador máximo de velocidad del juego.
    const SPEED_CHANGE_STEP = 0.2; // Incremento/decremento del multiplicador de velocidad del juego.
    const MAX_SUM_SPEED = 10; // Velocidad máxima de caída de las sumas.

    // Pits y Huecos (constantes de puntuación y penalización)
    const PITS_POINTS_AWARDED_WITH_RED_LIGHTS = 5; // Puntos por recoger un Pit si hay luces rojas.
    const PITS_POINTS_AWARDED_NO_RED_LIGHTS = 10; // Puntos por recoger un Pit si no hay luces rojas.
    const HOLE_SCORE_PENALTY = 1; // Penalización de puntos por colisionar con un Hueco.

    const COLLISION_FEEDBACK_MESSAGE_DURATION = 1500; // Duración de los mensajes de colisión en ms.

    // Constantes para el efecto de Barrera
    const BARRIER_EFFECT_SIMPLE_SUMS_MIN = 5; // Cantidad mínima de sumas sencillas durante el efecto Barrera.
    const BARRIER_EFFECT_SIMPLE_SUMS_MAX = 7; // Cantidad máxima de sumas sencillas durante el efecto Barrera.
    const BARRIER_EFFECT_RESUME_PAUSE_MS = 600; // Pequeña pausa antes de reanudar el juego tras el efecto Barrera.
    const BARRIER_EFFECT_MIN_DURATION_MS = 5000; // Duración mínima del efecto de Barrera en ms.
    const BARRIER_EFFECT_MAX_DURATION_MS = 10000; // Duración máxima del efecto de Barrera en ms.

    // Constantes KilleRRacing por nivel
    const KILLER_RACER_SPAWN_OPERATIONS_NOVATO = 5; // KilleRRacing aparece cada 5 operaciones en nivel Novato.
    const KILLER_RACER_SPAWN_OPERATIONS_EXPERTO = 5; // KilleRRacing aparece cada 5 operaciones en nivel Experto. (Ajustado de 4 a 5 según la última petición)
    const KILLER_RACER_ACCEL_POINT_PERCENTAGE = 0.5; // Porcentaje del carril donde KilleRRacing acelera/desacelera.
    var KILLER_RACER_SPAWN_COOLDOWN_S_PRINCIPIANTE = 30; // Cooldown de 30 segundos para principiante.

    // Constantes para el sistema de fases
    const SUMS_PER_OBJECT_PHASE_MIN = 3; // Mínimo de sumas a generar en la fase 'sums' antes de intentar generar un objeto.
    const SUMS_PER_OBJECT_PHASE_MAX = 6; // Máximo de sumas a generar en la fase 'sums'.
    // Cooldowns iniciales, se ajustarán en selectLevel
    let INITIAL_BARRIER_COOLDOWN = 15000; // Cooldown para la aparición de Barreras (15 segundos).
    let INITIAL_HOLE_COOLDOWN = 10000; // Cooldown para la aparición de Huecos (10 segundos).
    let INITIAL_PIT_COOLDOWN = 8000; // Cooldown para la aparición de Pits (8 segundos).

    let SUM_CREATION_INTERVAL = 1800; // Intervalo inicial para la creación de sumas (se ajusta por nivel).
    const INITIAL_SUM_GENERATION_BOOST_COUNT = 3; // Cuántas sumas se generan más rápido al inicio.
    const INITIAL_SUM_GENERATION_BOOST_INTERVAL = 1000; // Intervalo más rápido para las primeras sumas.


    // Duraciones de animación base para elementos CSS (segundos)
    const BASE_LINEA_CENTRAL_ANIM_DURATION = 2;
    const BASE_FRANJA_DIVISORIA_ANIM_DURATION = 1;
    const BASE_BOTTOM_TRACK_LINE_ANIM_DURATION = 1;

    // Tiempos de espera e intervalos (en ms) para feedback visual.
    const INCORRECT_ANSWER_FEEDBACK_TIME = 1000; // Duración del feedback de respuesta incorrecta.
    const CORRECT_ANSWER_EXPLOSION_TIME = 500; // Duración de la animación de explosión de respuesta correcta.
    const TURN_TRANSITION_MESSAGE_DELAY = 100; // Retraso antes de mostrar mensaje de transición de turno.


    // --- REFERENCIAS A ELEMENTOS DOM (se asignan en initGlobalDOMReferences) ---
    let roadMain;
    let bottomTrackLine;
    let globalOperationsFeedbackLightsContainer;
    let operationsLightbulbsRow;
    let globalScoreDisplay;
    let globalPitsPointsDisplay; // Ahora mostrará pitsAvailable
    let globalTimeDisplay;
    let gameControlsArea;
    let gameOverlay;
    let gameAreaContainer;
    let playerCarDisplay; // Referencia al elemento <img> del coche en la pista.

    let playerInputStrip;
    let unifiedControlsRow;

    let modeSelectionScreen;
    let levelSelectionScreen;
    let startScreenSolo;
    let startScreenTwoPlayers;
    let gameScreen;
    let resultsScreen;

    // --- ESTADO DE CONTROLES DEL JUGADOR ---
    let activeKeys = {
        ArrowLeft: false, ArrowRight: false, ArrowUp: false, ArrowDown: false
    };
    let activeButtons = {
        left: false, right: false, up: false, down: false
    };

    // --- VELOCIDADES AJUSTADAS DINÁMICAMENTE (se calculan en calculateDynamicSpeedsAndPositions) ---
    let ADJUSTED_CAR_MOVEMENT_SPEED;
    let ADJUSTED_SUM_HORIZONTAL_SPEED;
    let ADJUSTED_INITIAL_SUM_FALL_SPEED;
    let ADJUSTED_FALLING_OBJECT_SPEED;
    let ADJUSTED_TREE_CREATION_INTERVAL;
    let ADJUSTED_SUM_SPEED_INCREASE_VALUE;

    let commonControls = {}; // Objeto para agrupar referencias a los controles de UI.
    let globalOperationsFeedbackLights = []; // Array para las luces de feedback de operaciones.

    // Array de imágenes de árboles para decoración del fondo.
    const treeImages = [
      "https://i.postimg.cc/mDk00JXb/arbol-1.png", // 
      "https://i.postimg.cc/dQk0CxsP/rbol-2.png"  // 
    ];

    // Imágenes para las luces de Operaciones (ahora globales).
    const OPERATION_LIGHT_IMAGES = {
        'yellow': 'https://i.postimg.cc/43Sc42pN/L-Amarillo.png', // 
        'green': 'https://i.postimg.cc/RhrnK3Pk/L-Verde.png', // 
        'red': 'https://i.postimg.cc/SRpJjBRq/L-Roja.png' // 
    };

    // Estructura para almacenar la información de los jugadores.
    const players = [
      {
        id: 'player1',
        name: 'Player 1',
        score: 0,
        pitsPoints: 0, // Puntos acumulados por recoger Pits
        pitsAvailable: 0, // NUEVO: Cantidad de Pits disponibles para corregir errores futuros
        sumsAnsweredInRound: 0, // Sumas respondidas en la ronda actual (para las luces de feedback).
        correctAnswers: 0,
        incorrectAnswers: 0,
        car: null, // Referencia al elemento DOM del coche del jugador.
        carImage: "https://i.postimg.cc/CKbtKzx6/Jugador-1.png", // URL para el coche del Jugador 1 en pista 
        carabelaImage: "https://i.postimg.cc/gJ3B0X2t/IMG-Carabela-1.png", // URL para la carabela del Jugador 1 en resultados 
        nameDisplay: null, // Referencia al elemento DOM que muestra el nombre del jugador.
        scoreDisplay: null, pitsPointsDisplay: null, timeDisplay: null, // (Actualmente centralizados globalmente).
        answerBox: null, enterButton: null, resetButton: null, // (Actualmente centralizados globalmente).
        upButton: null, downButton: null, leftButton: null, rightButton: null, // (Actualmente centralizados globalmente).
        currentCarPosPx: 0, // Posición horizontal actual del coche en píxeles.
        currentCarBottomRem: MAX_CAR_VERTICAL_POS_REM, // Posición vertical actual del coche en vmin.
        currentSumSpeed: 0, // Velocidad de caída de las sumas para este jugador.
        laneElement: null, // Referencia al elemento DOM del carril del jugador.
        firstResponseTime: null, // Nuevo: Tiempo de respuesta de la primera operación (en ms).
      },
      {
        id: 'player2',
        name: 'Player 2',
        score: 0,
        pitsPoints: 0,
        pitsAvailable: 0, // NUEVO: Cantidad de Pits disponibles para corregir errores futuros
        sumsAnsweredInRound: 0,
        correctAnswers: 0,
        incorrectAnswers: 0,
        car: null,
        carImage: "https://i.postimg.cc/dtdMSqb6/Jugador-2.png", // URL para el coche del Jugador 2 en pista 
        carabelaImage: "https://i.postimg.cc/Qx5xNJ2k/IMG-Carabela-2.png", // URL para la carabela del Jugador 2 en resultados 
        nameDisplay: null,
        scoreDisplay: null, pitsPointsDisplay: null, timeDisplay: null,
        answerBox: null, enterButton: null, resetButton: null,
        upButton: null, downButton: null, leftButton: null, rightButton: null,
        currentCarPosPx: 0,
        currentCarBottomRem: MAX_CAR_VERTICAL_POS_REM,
        currentSumSpeed: 0,
        laneElement: null,
        firstResponseTime: null, // Nuevo: Tiempo de respuesta de la primera operación (en ms).
      }
    ];

    // Canvas for animated lines (new footer design)
    let animatedCanvas;
    let animatedCtx;
    const staticLineWidth = 2; // Thickness of the static lines
    const footerLinesPadding = 50; // Distance from the bottom of the canvas for the lines
    const numberOfStaticLines = 8; // Total number of static lines (4 yellow + 2 blue + 2 red)
    const glowBlur = 15; // Blur radius for the glow effect

    let gradientX = 0; // Starting X position for the animated gradient
    const gradientSpeed = 2; // Speed of the animated line movement (pixels per frame)
    const animatedLineHeight = staticLineWidth; // Animated line's height is same as static lines' width


    /**
     * Actualiza la visualización del tiempo en la interfaz del juego.
     * Gestiona la aparición de objetos especiales y sumas, controlando las fases del juego.
     * KilleRRacing y el efecto de Barrera tienen prioridad sobre la generación normal de elementos.
     */
    function updateTime() {
      if (gamePaused) return;

      let minutes = Math.floor(seconds / 60);
      let remainingSeconds = seconds % 60;
      if (globalTimeDisplay) {
          globalTimeDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${remainingSeconds.toString().padStart(2, '0')}`;
      }

      // Si KilleRRacing está en modo de ataque sobre la operación, el tiempo sigue contando, pero no se genera nada más.
      if (isKillerRacingAttacking) {
          seconds++;
          return;
      }

      // KilleRRacing en pista siempre tiene prioridad: si está activo, no se genera nada más y el tiempo sigue contando.
      if (killeRacingInstance) {
          seconds++;
          return;
      }

      // El efecto de Barrera también tiene prioridad y suspende el ciclo normal de fases.
      if (isBarrierEffectActive) {
          seconds++; // El tiempo sigue contando durante el efecto de barrera.
          return;
      }

      // Lógica principal de generación basada en fases para Pit, Hueco, Barrera.
      // Se intenta generar un objeto especial solo si estamos en la fase 'objects' y no se ha generado uno aún en esta fase.
      if (currentPhase === 'objects' && !objectGeneratedThisPhase) {
          trySpawnSpecialObject();
      }

      // KilleRRacing en nivel principiante sigue un patrón basado en el tiempo.
      // En Novato y Experto, su aparición es controlada por el contador de operaciones respondidas.
      if (currentLevel === 'principiante') {
          const MS_TO_S = 1000;
          // Cooldown de 30 segundos para principiante
          if (!killeRacingInstance && seconds >= 12 && (lastKillerRacerAppearanceTime === -Infinity || seconds >= (lastKillerRacerAppearanceTime + KILLER_RACER_SPAWN_COOLDOWN_S_PRINCIPIANTE))) {
              createKillerRacing(); // Esta función se encargará de restablecer la fase a 'sums'
              lastKillerRacerAppearanceTime = seconds;
          }
      }

      seconds++;
    }

    /**
     * Inicia el temporizador principal del juego, que actualiza la hora y la lógica de aparición de objetos/sumas.
     */
    function startTime() {
      if (!timeInterval) {
        timeInterval = setInterval(updateTime, 1000);
        console.log("Temporizador del juego iniciado.");
      }
    }

    /**
     * Pausa todas las animaciones del juego, incluyendo RequestAnimationFrame, setIntervals y animaciones CSS.
     */
    function pauseGame() {
        if (gamePaused) return;
        gamePaused = true;
        console.log("Juego Pausado.");
        
        // Detener animaciones de requestAnimationFrame (elementos que caen, KilleRRacing, bucle principal)
        activeRAFAnimations.forEach((animId, element) => {
            cancelAnimationFrame(animId);
            activeRAFAnimations.delete(element);
        });
        if (gameLoopId) {
            cancelAnimationFrame(gameLoopId);
            gameLoopId = null;
        }
        if (killeRacingAnimId) {
            cancelAnimationFrame(killeRacingAnimId);
            killeRacingAnimId = null;
        }
        // Detener animación de KilleRRacing en modo ataque
        if (killeRacingAttackAnimId) {
            cancelAnimationFrame(killeRacingAttackAnimId);
            killeRacingAttackAnimId = null;
        }

        // Detener intervalos de creación de elementos y el temporador principal.
        clearInterval(createSumInterval); 
        clearInterval(generateSimpleSumsInterval); 
        clearInterval(createTreesInterval); 
        clearInterval(timeInterval); 
        timeInterval = null; 

        // Pausar animaciones CSS aplicando una clase 'paused'.
        document.querySelectorAll('.linea-central, #franja-divisoria, #bottom-track-line, .arbol').forEach(el => { 
            el.classList.add('paused');
            el.style.animationPlayState = 'paused';
        });
    }

    /**
     * Reanuda todas las animaciones del juego que fueron pausadas.
     */
    function resumeGame() {
        if (!gamePaused) return;
        gamePaused = false;
        console.log("Juego Reanudado.");
        
        // Reanudar animaciones CSS removiendo la clase 'paused'.
        document.querySelectorAll('.linea-central, #franja-divisoria, #bottom-track-line, .arbol').forEach(el => { 
            el.classList.remove('paused');
            el.style.animationPlayState = 'running';
        });

        // Reanudar animaciones de elementos que caen (sumas, árboles, pits, barreras, huecos).
        document.querySelectorAll('.suma-caida, .arbol, .pit, .slowdown-strip, .hueco').forEach(element => {
            if (element.parentNode) {
                let speed;
                let type;
                if (element.classList.contains('suma-caida')) {
                    const sumPlayerId = element.dataset.playerId;
                    speed = players.find(p => p.id === sumPlayerId)?.currentSumSpeed;
                    type = 'sum';
                } else if (element.classList.contains('arbol')) {
                    speed = ADJUSTED_FALLING_OBJECT_SPEED;
                    type = 'tree';
                } else if (element.classList.contains('pit')) {
                    speed = ADJUSTED_FALLING_OBJECT_SPEED;
                    type = 'pit';
                } else if (element.classList.contains('slowdown-strip')) {
                    speed = ADJUSTED_FALLING_OBJECT_SPEED;
                    type = 'slowdown-strip';
                } else if (element.classList.contains('hueco')) {
                    speed = ADJUSTED_FALLING_OBJECT_SPEED;
                    type = 'hueco';
                } else {
                    return;
                }
                if (activeRAFAnimations.has(element)) {
                    cancelAnimationFrame(activeRAFAnimations.get(element)); 
                }
                const animId = requestAnimationFrame(() => moveElement(element, speed, type));
                activeRAFAnimations.set(element, animId);
            }
        });

        // Reanudar animación de KilleRRacing si existe (en pista).
        if (killeRacingInstance && !killeRacingAnimId) {
            killeRacingAnimId = requestAnimationFrame(moveKillerRacing);
        }
        // Reanudar animación de KilleRRacing en modo ataque si existe.
        if (isKillerRacingAttacking && killeRacingAttackInstance && !killeRacingAttackAnimId) {
            killeRacingAttackAnimId = requestAnimationFrame(() => animateKillerRacingAttack(currentCollidingSum));
        }

        // Reanudar el temporador principal del juego.
        startTime(); 

        // Reanudar la creación de árboles.
        clearInterval(createTreesInterval); 
        createTreesInterval = setInterval(createTrees, ADJUSTED_TREE_CREATION_INTERVAL); 
        
        // Reanudar la creación de sumas/objetos según la fase actual o si el efecto de barrera está activo.
        clearInterval(createSumInterval); 
        clearInterval(generateSimpleSumsInterval); 

        if (isBarrierEffectActive) {
            generateSimpleSumsInterval = setInterval(() => {
                createSum(); 
            }, 400); 
        } else if (currentPhase === 'sums') {
            createSumInterval = setInterval(createSum, SUM_CREATION_INTERVAL);
        }
        // Si currentPhase es 'objects', no se necesita un intervalo directo aquí; `updateTime` se encarga de llamar a `trySpawnSpecialObject`.

        // Reanudar el bucle principal del juego.
        if (!gameLoopId) {
            gameLoopId = requestAnimationFrame(gameLoop);
        }
    }

    /**
     * Activa o desactiva la interactividad y apariencia visual de los controles de dirección.
     * @param {boolean} isActive - True para activar los controles, false para desactivarlos y atenuarlos.
     */
    function setDirectionalControlsActive(isActive) {
        if (unifiedControlsRow) {
            unifiedControlsRow.classList.toggle('inactive-controls', !isActive);
            Array.from(unifiedControlsRow.querySelectorAll('button')).forEach(button => {
                button.disabled = !isActive;
            });
        }
    }

    /**
     * Activa o desactiva la interactividad y apariencia visual de la franja de entrada de respuesta.
     * @param {boolean} isActive - True para activar los controles, false para desactivarlos y atenuarlos.
     */
    function setInputControlsActive(isActive) {
        if (playerInputStrip) {
            playerInputStrip.classList.toggle('inactive-controls', !isActive);
            if (commonControls.answerBox) commonControls.answerBox.disabled = !isActive;
            if (commonControls.enterButton) commonControls.enterButton.disabled = !isActive;
            if (commonControls.resetButton) commonControls.resetButton.disabled = !isActive;
        }
    }

    /**
     * Calcula una posición horizontal para un nuevo obstáculo en un carril específico.
     * La vía se considera dividida lógicamente en dos sub-carriles (izquierdo y derecho).
     *
     * @param {HTMLElement} targetLane - El elemento del carril donde se colocará el obstáculo.
     * @param {number} obstacleWidth - El ancho del nuevo obstáculo en píxeles.
     * @param {string} laneType - Define la posición horizontal:
     * - 'left-sublane': Posiciona el objeto en el centro del sub-carril izquierdo.
     * - 'right-sublane': Posiciona el objeto en el centro del sub-carril derecho.
     * - 'full-lane': Posiciona el objeto aleatoriamente en todo el carril (usado para sumas).
     * - 'center-lane': Posiciona el objeto en el centro exacto del carril.
     * @returns {number} La posición 'left' calculada en píxeles.
     */
    function calculateHorizontalPositionInLane(targetLane, obstacleWidth, laneType) {
        const laneWidth = targetLane.offsetWidth;
        let initialLeftPx;

        const subLaneWidth = laneWidth * 0.5; // Cada sub-carril ocupa la mitad del carril principal
        const horizontalPadding = 0.05 * laneWidth; // 5% de padding para evitar que se peguen a los bordes
        const effectiveSubLaneWidth = subLaneWidth - 2 * horizontalPadding; // Ancho utilizable por sub-carril

        switch (laneType) {
            case 'left-sublane':
                // Centrar en el sub-carril izquierdo
                initialLeftPx = horizontalPadding + (effectiveSubLaneWidth / 2) - (obstacleWidth / 2);
                break;
            case 'right-sublane':
                // Centrar en el sub-carril derecho
                initialLeftPx = subLaneWidth + horizontalPadding + (effectiveSubLaneWidth / 2) - (obstacleWidth / 2);
                break;
            case 'full-lane': // Para sumas, se posiciona en todo el ancho del carril
                initialLeftPx = Math.random() * (laneWidth - obstacleWidth);
                break;
            case 'center-lane': // Nuevo: Posiciona en el centro exacto del carril
                initialLeftPx = (laneWidth / 2) - (obstacleWidth / 2);
                break;
            default:
                initialLeftPx = Math.random() * (laneWidth - obstacleWidth); // Fallback
        }

        // Asegurarse de que el objeto no se salga de los límites del carril.
        initialLeftPx = Math.max(0, Math.min(initialLeftPx, laneWidth - obstacleWidth));
        return initialLeftPx;
    }

    /**
     * Función genérica para mover elementos que caen (sumas, árboles, pits, barreras, huecos).
     * Cada elemento tiene su propia animación controlada por RequestAnimationFrame.
     * @param {HTMLElement} element - El elemento DOM a mover.
     * @param {number} verticalSpeed - La velocidad vertical base del elemento en píxeles por frame.
     * @param {string} type - El tipo de elemento ('sum', 'tree', 'pit', 'slowdown-strip', 'hueco').
     */
    function moveElement(element, verticalSpeed, type) {
        // Solicitar el siguiente frame de animación y almacenar su ID para poder cancelarlo.
        const animId = requestAnimationFrame(() => moveElement(element, verticalSpeed, type));
        activeRAFAnimations.set(element, animId);

        if (!gamePaused) {
            let posTop = parseFloat(element.style.top);
            element.style.top = posTop + (verticalSpeed * gameSpeedMultiplier) + "px";

            // Manejo del movimiento horizontal para sumas (oscilación de lado a lado).
            if (type === 'sum') { 
                let posLeft = parseFloat(element.style.left);
                let currentDirection = element.dataset.direction;
                
                const targetLane = document.getElementById(element.dataset.playerLaneId || 'player1-lane'); 
                let laneWidth = targetLane ? targetLane.offsetWidth : 0;

                const currentElementWidth = element.offsetWidth;
                const leftLaneLimit = 0;
                const rightLaneLimit = laneWidth - currentElementWidth;
                
                let adjustedHorizontalSpeed = INITIAL_SUM_HORIZONTAL_SPEED_BASE * gameSpeedMultiplier;

                if (currentDirection === 'right') {
                    posLeft += adjustedHorizontalSpeed;
                    if (posLeft >= rightLaneLimit) {
                        posLeft = rightLaneLimit;
                        element.dataset.direction = 'left';
                    }
                } else { // direction === 'left'
                    posLeft -= adjustedHorizontalSpeed;
                    if (posLeft <= leftLaneLimit) {
                        posLeft = leftLaneLimit;
                        element.dataset.direction = 'right';
                    }
                }
                element.style.left = posLeft + "px";
            }

            const bottomLineRect = bottomTrackLine.getBoundingClientRect();
            const elementRect = element.getBoundingClientRect();

            // Si el elemento ha cruzado la línea inferior de la pista, removerlo.
            if (elementRect.top >= bottomLineRect.top) {
                if (element.parentNode) {
                    element.parentNode.removeChild(element);
                }
                // Si es una suma sencilla del efecto barrera, decrementa el contador.
                if (type === 'sum' && element.dataset.sumDifficulty === 'sencilla-barrera') {
                    barrierSimpleSumsCounter--;
                    // Verifica si el contador ha llegado a cero o si el tiempo del efecto ha pasado.
                    if (barrierSimpleSumsCounter <= 0 || (barrierTimeElapsed && (Date.now() - barrierEffectStartTime) >= BARRIER_EFFECT_MIN_DURATION_MS)) {
                        endBarrierEffect();
                    }
                }
                // Liberar el carril si el elemento tenía asignado un sub-carril.
                if (element.dataset.subLane) {
                    laneOccupancy[element.dataset.subLane] = false;
                }
                cancelAnimationFrame(animId);
                activeRAFAnimations.delete(element);
                return;
            }
        }
    }

    /**
     * Crea y posiciona un solo árbol en el jardín especificado.
     * Los árboles son elementos decorativos y no interactúan con el juego principal.
     * @param {string} targetGardenId - El ID del elemento del jardín donde se colocará el árbol.
     */
    function createSingleTree(targetGardenId) {
        if (gamePaused) return;

        const treeElement = document.createElement("img");
        treeElement.classList.add("arbol");
        treeElement.src = treeImages[Math.floor(Math.random() * treeImages.length)];
        
        const targetGarden = document.getElementById(targetGardenId);
        if (!targetGarden) return;

        treeElement.style.position = 'absolute';
        treeElement.style.top = (Math.random() * 100 - 150) + "px"; // Inicia aleatoriamente fuera de pantalla por arriba.
        treeElement.style.visibility = 'hidden'; 
        targetGarden.appendChild(treeElement);

        const currentGardenWidth = targetGarden.offsetWidth;
        const treeWidthRatio = 0.8; 
        const actualTreeWidth = currentGardenWidth * treeWidthRatio;
        const availableHorizontalSpace = currentGardenWidth - actualTreeWidth;
        let initialLeft = availableHorizontalSpace > 0 ? Math.random() * availableHorizontalSpace : 0;

        treeElement.style.left = initialLeft + "px";
        treeElement.style.visibility = 'visible'; 
        
        moveElement(treeElement, ADJUSTED_FALLING_OBJECT_SPEED, 'tree');
    }

    /**
     * Crea árboles de forma periódica en ambos jardines del juego.
     */
    function createTrees() { 
        if (gamePaused) return;
        createSingleTree("jardin-izquierdo");
        createSingleTree("jardin-derecho");
    }

    /**
     * Función auxiliar para obtener un carril disponible (izquierdo o derecho) para un nuevo objeto especial.
     * Los carriles se marcan como ocupados para evitar que los objetos se superpongan horizontalmente.
     * @returns {string|null} 'left' o 'right' si un carril está disponible, de lo contrario null.
     */
    function getAvailableLane() {
        const availableLanes = [];
        if (!laneOccupancy.left) {
            availableLanes.push('left');
        }
        if (!laneOccupancy.right) {
            availableLanes.push('right');
        }

        if (availableLanes.length === 0) {
            return null; // No hay carriles disponibles.
        } else if (availableLanes.length === 1) {
            return availableLanes[0]; // Solo un carril disponible.
        } else {
            return Math.random() < 0.5 ? 'left' : 'right'; // Elegir aleatoriamente entre los dos.
        }
    }

    /**
     * Intenta generar un objeto especial (Pit, Hueco, Barrera) si el juego está en la fase 'objects'
     * y los tiempos de reutilización (cooldowns) lo permiten.
     */
    function trySpawnSpecialObject() {
        // No generar si el juego está pausado, KilleRRacing o el efecto de Barrera están activos,
        // o si un objeto ya se generó en esta fase de 'objects'.
        if (gamePaused || killeRacingInstance || isKillerRacingAttacking || isBarrierEffectActive || objectGeneratedThisPhase) return; 

        const MS_TO_S = 1000; // Constante para convertir milisegundos a segundos.
        const availableObjects = []; // Lista de objetos especiales que pueden generarse.

        // Comprobar los tiempos de reutilización (cooldowns) para cada tipo de objeto.
        // Los objetos Pit, Hueco y Barrera tienen cooldowns para evitar apariciones consecutivas.
        if (seconds >= 4 && (lastBarrierAppearanceTime === -Infinity || seconds >= (lastBarrierAppearanceTime + INITIAL_BARRIER_COOLDOWN / MS_TO_S))) {
            availableObjects.push('barrier');
        }
        if (seconds >= 7 && (lastHoleAppearanceTime === -Infinity || seconds >= (lastHoleAppearanceTime + INITIAL_HOLE_COOLDOWN / MS_TO_S))) {
            availableObjects.push('hole');
        }
        if (seconds >= 9 && (lastPitAppearanceTime === -Infinity || seconds >= (lastPitAppearanceTime + INITIAL_PIT_COOLDOWN / MS_TO_S))) {
            availableObjects.push('pit');
        }

        if (availableObjects.length > 0) {
            // Elegir un tipo de objeto aleatoriamente de los disponibles.
            const chosenObjectType = availableObjects[Math.floor(Math.random() * availableObjects.length)];
            let objectCreated = false;
            switch (chosenObjectType) {
                case 'barrier':
                    createSlowdownStrip();
                    lastBarrierAppearanceTime = seconds; // Actualizar el tiempo de última aparición.
                    objectCreated = true;
                    break;
                case 'hole':
                    createHole();
                    lastHoleAppearanceTime = seconds; // Actualizar el tiempo de última aparición.
                    objectCreated = true;
                    break;
                case 'pit':
                    createPit();
                    lastPitAppearanceTime = seconds; // Actualizar el tiempo de última aparición.
                    objectCreated = true;
                    break;
            }
            if (objectCreated) {
                objectGeneratedThisPhase = true; // Marcar que se generó un objeto en esta fase.
                console.log(`DEBUG: Objeto especial '${chosenObjectType}' generado. Transicionando a fase de sumas.`);
                currentPhase = 'sums'; // Cambiar a la fase de sumas.
                // Calcular cuántas sumas se generarán en la nueva fase de sumas.
                sumsCountForCurrentPhase = Math.floor(Math.random() * (SUMS_PER_OBJECT_PHASE_MAX - SUMS_PER_OBJECT_PHASE_MIN + 1)) + SUMS_PER_OBJECT_PHASE_MIN;
                currentSumsGeneratedInPhase = 0; // Reiniciar el contador de sumas generadas en la fase.
                // Asegurarse de que el intervalo de sumas esté funcionando para la nueva fase.
                if (createSumInterval) clearInterval(createSumInterval);
                createSumInterval = setInterval(createSum, SUM_CREATION_INTERVAL);
            }
        } else {
            // Si no hay objetos disponibles para generar (por cooldowns o carriles ocupados),
            // se fuerza una transición de vuelta a la fase de sumas para evitar bloqueos.
            console.log("DEBUG: Fase de objetos activa, pero no hay objetos disponibles para generar según los cooldowns o carriles. Forzando transición a fase de sumas.");
            currentPhase = 'sums';
            sumsCountForCurrentPhase = Math.floor(Math.random() * (SUMS_PER_OBJECT_PHASE_MAX - SUMS_PER_OBJECT_PHASE_MIN + 1)) + SUMS_PER_OBJECT_PHASE_MIN;
            currentSumsGeneratedInPhase = 0;
            objectGeneratedThisPhase = false; // Permitir que un nuevo intento de objeto se realice en el próximo ciclo de fase 'objects'.
            if (createSumInterval) clearInterval(createSumInterval);
            createSumInterval = setInterval(createSum, SUM_CREATION_INTERVAL);
        }
    }

    /**
     * Crea un nuevo elemento Pit (ícono de llave inglesa) en la pista de juego.
     * Rol: Los Pits son objetos que el jugador puede "recoger" para corregir errores (luces rojas)
     * o ganar puntos adicionales si no hay errores.
     */
    function createPit() {
        if (gamePaused || killeRacingInstance || isKillerRacingAttacking || isBarrierEffectActive || currentPhase !== 'objects' || objectGeneratedThisPhase) return; 

        const chosenLane = getAvailableLane(); // Obtener un sub-carril disponible.
        if (!chosenLane) {
            console.log("No hay carril disponible para Pit. No se crea.");
            return; 
        }
        
        const pitElement = document.createElement("div");
        pitElement.classList.add("pit");
        
        const targetLane = document.getElementById('player1-lane');
        if (!targetLane) return;
        
        pitElement.style.position = 'absolute';
        pitElement.style.top = (Math.random() * 100 - 150) + "px"; // Inicia fuera de la pantalla por arriba.
        pitElement.style.visibility = 'hidden'; // Ocultar mientras se posiciona.
        targetLane.appendChild(pitElement); 

        const pitWidth = pitElement.offsetWidth;
        const initialLeftPx = calculateHorizontalPositionInLane(targetLane, pitWidth, `${chosenLane}-sublane`); // Posicionar en el sub-carril.
        pitElement.style.left = initialLeftPx + "px";
        pitElement.style.visibility = 'visible'; // Hacer visible después de posicionar.
        pitElement.dataset.playerId = players[gameRound].id;
        pitElement.dataset.playerLaneId = 'player1-lane';
        pitElement.dataset.subLane = chosenLane; // Guardar el sub-carril en el dataset.
        
        laneOccupancy[chosenLane] = true; // Marcar el carril como ocupado.
        moveElement(pitElement, ADJUSTED_FALLING_OBJECT_SPEED, 'pit'); // Iniciar movimiento.
    }

    /**
     * Maneja la colisión del jugador con una franja de ralentización (Barrera).
     * Rol: Inicia el efecto de "Pista Fácil" donde solo aparecen sumas de una cifra.
     * @param {HTMLElement} stripElement - El elemento de la franja de ralentización con el que se colisionó.
     * @param {number} playerIndex - El índice del jugador que colisionó con la franja.
     */
    function handleSlowdownStripCollision(stripElement, playerIndex) {
        const player = players[playerIndex];
        if (!player) return;

        const stripRect = stripElement.getBoundingClientRect();
        showCollisionFeedbackMessage("¡PISTA FÁCIL!", stripRect, gameAreaContainer); // Mostrar mensaje de efecto.

        // Remover la franja de la pantalla y liberar su animación.
        if (stripElement.parentNode) {
            stripElement.parentNode.removeChild(stripElement);
            activeRAFAnimations.delete(stripElement); 
        }
        // Liberar el carril que ocupaba la franja.
        if (stripElement.dataset.subLane) {
            laneOccupancy[stripElement.dataset.subLane] = false;
        }

        // INICIO de la lógica del efecto de barrera con duración y contador.
        isBarrierEffectActive = true; 
        barrierSimpleSumsCounter = Math.floor(Math.random() * (BARRIER_EFFECT_SIMPLE_SUMS_MAX - BARRIER_EFFECT_SIMPLE_SUMS_MIN + 1)) + BARRIER_EFFECT_SIMPLE_SUMS_MIN;
        barrierEffectStartTime = Date.now();
        barrierEffectDuration = Math.random() * (BARRIER_EFFECT_MAX_DURATION_MS - BARRIER_EFFECT_MIN_DURATION_MS) + BARRIER_EFFECT_MIN_DURATION_MS;
        barrierTimeElapsed = false;

        // Establece un timeout para marcar que el tiempo de la barrera ha transcurrido.
        setTimeout(() => {
            barrierTimeElapsed = true;
            // Si el contador de sumas ya llegó a cero, termina el efecto inmediatamente.
            if (barrierSimpleSumsCounter <= 0) {
                endBarrierEffect();
            }
        }, barrierEffectDuration);

        // Detener los intervalos de generación normal de sumas y árboles.
        clearInterval(createSumInterval); 
        clearInterval(createTreesInterval); 
        clearInterval(generateSimpleSumsInterval); 

        // Iniciar la generación de sumas sencillas específicamente para el efecto de barrera.
        generateSimpleSumsInterval = setInterval(() => {
            createSum(); 
        }, 400); 
    }


    /**
     * Crea una nueva franja de ralentización (Barrera) en la pista de juego.
     * Rol: Las Barreras, al ser colisionadas, inician un efecto temporal de "Pista Fácil",
     * donde solo aparecen sumas de una cifra.
     */
    function createSlowdownStrip() {
        if (gamePaused || killeRacingInstance || isKillerRacingAttacking || isBarrierEffectActive || currentPhase !== 'objects' || objectGeneratedThisPhase) return; 

        const chosenLane = getAvailableLane(); // Obtener un sub-carril disponible.
        if (!chosenLane) {
            console.log("No hay carril disponible para Barrera. No se crea.");
            return;
        }

        const stripElement = document.createElement("div");
        stripElement.classList.add("slowdown-strip");
        
        const targetLane = document.getElementById('player1-lane');
        if (!targetLane) return;

        stripElement.style.position = 'absolute';
        stripElement.style.top = (Math.random() * 100 - 150) + "px"; // Inicia fuera de la pantalla por arriba.
        stripElement.style.visibility = 'hidden'; // Ocultar mientras se posiciona.
        targetLane.appendChild(stripElement); 

        const stripWidth = stripElement.offsetWidth;
        const initialLeftPx = calculateHorizontalPositionInLane(targetLane, stripWidth, `${chosenLane}-sublane`); // Posicionar en el sub-carril.
        stripElement.style.left = initialLeftPx + "px";
        stripElement.style.visibility = 'visible'; // Hacer visible después de posicionar.
        stripElement.dataset.playerId = players[gameRound].id;
        stripElement.dataset.playerLaneId = 'player1-lane';
        stripElement.dataset.subLane = chosenLane; // Guardar el sub-carril en el dataset.
        
        laneOccupancy[chosenLane] = true; // Marcar el carril como ocupado.
        moveElement(stripElement, ADJUSTED_FALLING_OBJECT_SPEED, 'slowdown-strip'); // Iniciar movimiento.
    }

    /**
     * Finaliza el efecto de la barrera (Pista Fácil) y reanuda la generación normal de objetos.
     * Restablece la fase del juego a 'sums' para continuar el ciclo normal.
     */
    function endBarrierEffect() {
        // Solo terminar el efecto si ambas condiciones se cumplen:
        // 1. El contador de sumas sencillas ha llegado a 0.
        // 2. El tiempo mínimo del efecto de barrera ha transcurrido.
        if (isBarrierEffectActive && (barrierSimpleSumsCounter <= 0 || barrierTimeElapsed)) { 
            isBarrierEffectActive = false; 

            // Remover cualquier suma sencilla restante que haya sido generada por el efecto de barrera.
            document.querySelectorAll('.suma-caida[data-sum-difficulty="sencilla-barrera"]').forEach(el => {
                if (el.parentNode) {
                    el.parentNode.removeChild(el);
                    activeRAFAnimations.delete(el);
                }
            });

            clearInterval(generateSimpleSumsInterval); 
            generateSimpleSumsInterval = null;
            
            setTimeout(() => {
                // Restablecer la fase normal del juego después de que termina el efecto de barrera.
                currentPhase = 'sums';
                // Recalcular el número de sumas para la nueva fase.
                sumsCountForCurrentPhase = Math.floor(Math.random() * (SUMS_PER_OBJECT_PHASE_MAX - SUMS_PER_OBJECT_PHASE_MIN + 1)) + SUMS_PER_OBJECT_PHASE_MIN;
                currentSumsGeneratedInPhase = 0; // Reiniciar el contador de sumas generadas en la fase.
                objectGeneratedThisPhase = false; // Permitir la generación de un nuevo objeto especial en la siguiente fase de 'objects'.
                
                // Reiniciar los intervalos de generación normal de sumas y árboles.
                clearInterval(createSumInterval); 
                createSumInterval = setInterval(createSum, SUM_CREATION_INTERVAL); 

                clearInterval(createTreesInterval); 
                createTreesInterval = setInterval(createTrees, ADJUSTED_TREE_CREATION_INTERVAL); 

                resumeGame(); // Reanudar el juego.
                setDirectionalControlsActive(true); // Activar controles de dirección.
                setInputControlsActive(false); // Desactivar controles de entrada.
                console.log("DEBUG: Efecto de Barrera finalizado. Juego normal reanudado.");
            }, BARRIER_EFFECT_RESUME_PAUSE_MS);
        }
    }

    /**
     * Crea un nuevo elemento Hueco en la pista de juego.
     * Rol: Los Huecos, al ser colisionados, penalizan al jugador quitando un punto
     * y transformando una luz verde (respuesta correcta) en una roja.
     */
    function createHole() {
        if (gamePaused || killeRacingInstance || isKillerRacingAttacking || isBarrierEffectActive || currentPhase !== 'objects' || objectGeneratedThisPhase) return; 

        let chosenLane = null;
        const occupiedLanes = [];
        if (laneOccupancy.left) occupiedLanes.push('left');
        if (laneOccupancy.right) occupiedLanes.push('right');

        if (occupiedLanes.length > 0) {
            // Si hay carriles ocupados por otros objetos (Pit/Barrera), prioriza uno de ellos.
            chosenLane = occupiedLanes[Math.floor(Math.random() * occupiedLanes.length)];
        } else {
            // Si no hay carriles ocupados, elige un carril libre aleatoriamente.
            const freeLanes = [];
            if (!laneOccupancy.left) freeLanes.push('left');
            if (!laneOccupancy.right) freeLanes.push('right');
            if (freeLanes.length > 0) {
                chosenLane = freeLanes[Math.floor(Math.random() * freeLanes.length)];
            }
        }

        if (!chosenLane) {
            console.log("No hay carril disponible o adecuado para Hueco. No se crea.");
            return;
        }

        const holeElement = document.createElement("div");
        holeElement.classList.add("hueco");
        
        const targetLane = document.getElementById('player1-lane');
        if (!targetLane) return;

        holeElement.style.position = 'absolute';
        
        let initialTop = (Math.random() * 100 - 150); // Posición inicial aleatoria por defecto.

        // Buscar si hay un Pit o Barrera existente en el carril elegido para posicionar el Hueco cerca.
        const existingObstacles = document.querySelectorAll('.pit, .slowdown-strip');
        let targetObstacle = null;
        for (const obs of existingObstacles) {
            if (obs.dataset.subLane === chosenLane) {
                targetObstacle = obs;
                break;
            }
        }

        if (targetObstacle) {
            // Si hay un obstáculo en el carril, posicionar el Hueco cerca de su posición vertical.
            const obstacleTop = parseFloat(targetObstacle.style.top);
            // Generar una posición vertical dentro de un rango de +/- 50px del obstáculo.
            initialTop = obstacleTop + (Math.random() * 100 - 50);
            // Asegurarse de que no se genere demasiado arriba fuera de la pantalla.
            initialTop = Math.max(-150, initialTop);
        }

        holeElement.style.top = initialTop + "px";
        holeElement.style.visibility = 'hidden'; // Ocultar mientras se posiciona.
        targetLane.appendChild(holeElement); 
        
        const holeWidth = holeElement.offsetWidth;
        const initialLeftPx = calculateHorizontalPositionInLane(targetLane, holeWidth, `${chosenLane}-sublane`); // Posicionar en el sub-carril.
        holeElement.style.left = initialLeftPx + "px";
        holeElement.style.visibility = 'visible'; // Hacer visible después de posicionar.
        holeElement.dataset.playerId = players[gameRound].id;
        holeElement.dataset.playerLaneId = 'player1-lane';
        holeElement.dataset.subLane = chosenLane; // Guardar el sub-carril en el dataset.
        
        laneOccupancy[chosenLane] = true; // Marcar el carril como ocupado (por el nuevo hueco).
        moveElement(holeElement, ADJUSTED_FALLING_OBJECT_SPEED, 'hueco'); // Iniciar movimiento.
    }

    /**
     * Genera un par de números aleatorios para problemas de suma, basándose en el nivel de dificultad actual.
     * @param {string} level - El nivel de dificultad actual ('principiante', 'novato', 'experto').
     * @param {boolean} isBarrierEffect - True si se está generando una suma para el efecto de barrera (más sencilla).
     * @returns {Array<number>} Un array `[num1, num2]` con los números para la suma.
     */
    function generateNumbersForSum(level, isBarrierEffect) { 
        if (isBarrierEffect) {
            // Sumas sencillas solo con 1 y 2
            let numA = Math.random() < 0.5 ? 1 : 2;
            let numB = Math.random() < 0.5 ? 1 : 2;
            return [numA, numB];
        } else {
            switch (level) {
                case 'principiante': return [Math.floor(Math.random() * 9) + 1, Math.floor(Math.random() * 9) + 1];
                case 'novato': return [Math.floor(Math.random() * 90) + 10, Math.floor(Math.random() * 90) + 10];
                case 'experto': return [Math.floor(Math.random() * 900) + 100, Math.floor(Math.random() * 900) + 100];
                default: return [Math.floor(Math.random() * 9) + 1, Math.floor(Math.random() * 9) + 1];
            }
        }
    }

    /**
     * Crea un nuevo elemento de suma y lo agrega a la pista de juego.
     * La lógica de generación se adapta según la fase actual o si el efecto de barrera está activo.
     */
    function createSum() {
        // Permitir la creación de sumas si el juego está pausado solo para depuración.
        if (gamePaused && !isBarrierEffectActive) return; 
        // No crear sumas si KilleRRacing está activo (en pista o en ataque), ya que tiene prioridad visual y lógica.
        if (killeRacingInstance || isKillerRacingAttacking) return;

        let num1, num2, correctAnswer, pointsValue, sumDifficultyType;
        
        // Determina si es una suma de barrera (efecto "Pista Fácil") o una suma regular.
        const isCurrentlyBarrierSum = isBarrierEffectActive && barrierSimpleSumsCounter > 0;

        if (isCurrentlyBarrierSum) {
            [num1, num2] = generateNumbersForSum(currentLevel, true); // Genera números para sumas de barrera.
            correctAnswer = num1 + num2;
            pointsValue = 1; // Las sumas de barrera dan 1 punto.
            sumDifficultyType = 'sencilla-barrera';
            console.log(`DEBUG: Generando suma sencilla (Barrera): ${num1}+${num2}`);
        } else {
            // Si no hay efecto de barrera, se aplican las reglas de fase normales.
            if (currentPhase !== 'sums' || currentSumsGeneratedInPhase >= sumsCountForCurrentPhase) {
                // No se crea la suma si no es la fase de sumas o se ha alcanzado el límite de sumas por fase.
                return;
            }
            [num1, num2] = generateNumbersForSum(currentLevel, false); // Genera números para sumas regulares.
            correctAnswer = num1 + num2;
            pointsValue = calculatePoints(num1, num2, false);
            sumDifficultyType = currentLevel;
            console.log(`DEBUG: Generando suma regular: ${num1}+${num2}`);
        }

        const sumElement = document.createElement("div");
        sumElement.classList.add("suma-caida");

        sumElement.textContent = `${num1}+${num2}`;
        sumElement.dataset.respuesta = correctAnswer;
        sumElement.dataset.valorPuntos = pointsValue;
        sumElement.dataset.sumDifficulty = sumDifficultyType;
        sumElement.dataset.direction = Math.random() < 0.5 ? 'left' : 'right'; // Dirección horizontal de la suma.

        const activePlayer = players[gameRound];
        const targetLane = document.getElementById('player1-lane');
        sumElement.dataset.playerId = activePlayer.id;
        sumElement.dataset.playerLaneId = 'player1-lane';

        if (!targetLane) return;

        sumElement.style.position = 'absolute';
        sumElement.style.top = (Math.random() * 100 - 150) + "px"; // Inicia fuera de la pantalla por arriba.
        sumElement.style.visibility = 'hidden'; // Ocultar mientras se posiciona.
        targetLane.appendChild(sumElement);

        const currentSumWidth = sumElement.offsetWidth;
        const targetLaneWidth = targetLane.offsetWidth;
        const horizontalRangeAvailable = targetLaneWidth - currentSumWidth;

        let initialLeftPx = horizontalRangeAvailable <= 0 ? 0 : Math.random() * horizontalRangeAvailable;
        sumElement.style.left = initialLeftPx + "px";
        sumElement.style.visibility = 'visible'; // Hacer visible después de posicionar.

        moveElement(sumElement, activePlayer.currentSumSpeed, 'sum'); // Iniciar movimiento.

        // Solo incrementa el contador de sumas generadas para la fase si NO es una suma de barrera.
        if (!isCurrentlyBarrierSum) {
            currentSumsGeneratedInPhase++;
            console.log(`DEBUG: Suma regular generada. Contador de fase: ${currentSumsGeneratedInPhase}/${sumsCountForCurrentPhase}`);
            // Si hemos generado suficientes sumas regulares, preparar la transición a la fase de objetos.
            if (currentSumsGeneratedInPhase >= sumsCountForCurrentPhase) {
                console.log("DEBUG: Límite de sumas en fase alcanzado. Preparando transición a fase de objetos.");
                currentPhase = 'objects';
                objectGeneratedThisPhase = false; // Permitir que un objeto se genere en la siguiente fase.
                clearInterval(createSumInterval); // Detener la generación de sumas regulares.
                createSumInterval = null;
            }
        }
    }

    /**
     * Calcula los puntos a otorgar por un problema de suma resuelto correctamente.
     * La dificultad de la suma y el estado del efecto de barrera influyen en la puntuación.
     * @param {number} num1 - El primer número de la suma.
     * @param {number} num2 - El segundo número de la suma.
     * @param {boolean} isBarrierEffectActive - True si el efecto de barrera está activo (sumas más sencillas).
     * @returns {number} Los puntos otorgados.
     */
    function calculatePoints(num1, num2, isBarrierEffectActive) { 
        let points = 0;
        if (isBarrierEffectActive) {
            points = 1; // Las sumas generadas durante el efecto de barrera dan menos puntos.
        } else {
            // Lógica de puntos basada en el tamaño de los números para sumas regulares.
            if (num1 < 10 && num2 < 10) { 
                if (num1 >= 1 && num1 <= 3) { points = 1; }
                else if (num1 >= 4 && num1 <= 6) { points = 2; }
                else if (num1 >= 7 && num1 <= 8) { points = 3; }
                else if (num1 === 9) { points = 5; }
                else { points = 0; } 

                if (num1 === 7 || num2 === 7 || num1 === 8 || num2 === 8) {
                    points += 2;
                } else if (num1 === 9 || num2 === 9) {
                    points += 3;
                }
            } else { 
                points = 10; // Sumas de dos o más cifras dan más puntos.
            }
        }
        return points;
    }

    /**
     * Actualiza la duración de las animaciones CSS de varios elementos (líneas de la pista)
     * para ajustar la velocidad visual de acuerdo con el `gameSpeedMultiplier`.
     */
    function updateCSSAnimationsSpeed() {
        const lineaCentral = document.querySelector('.linea-central');
        const franjaDivisoria = document.getElementById('franja-divisoria');
        const bottomTrackLine = document.getElementById('bottom-track-line');

        if (lineaCentral) {
            lineaCentral.style.animationDuration = `${BASE_LINEA_CENTRAL_ANIM_DURATION / gameSpeedMultiplier}s`;
        }
        if (franjaDivisoria) {
            franjaDivisoria.style.animationDuration = `${BASE_FRANJA_DIVISORIA_ANIM_DURATION / gameSpeedMultiplier}s`;
        }
        if (bottomTrackLine) {
            bottomTrackLine.style.animationDuration = `${BASE_BOTTOM_TRACK_LINE_ANIM_DURATION / gameSpeedMultiplier}s`;
        }
    }

    /**
     * Acelera la velocidad general del juego y mueve visualmente el coche del jugador hacia arriba en la pantalla.
     */
    function accelerate() {
        if (gamePaused) return;
        gameSpeedMultiplier = Math.min(MAX_GAME_SPEED_MULTIPLIER, gameSpeedMultiplier + SPEED_CHANGE_STEP);
        updateCSSAnimationsSpeed(); // Actualizar animaciones CSS para reflejar la nueva velocidad.

        const player = players[gameRound];
        if (player.car) {
            const carWidth = player.car.offsetWidth; // Define carWidth here
            // Mover el coche hacia arriba (hacia el mínimo 'bottom' vmin).
            player.currentCarBottomRem = Math.min(MIN_CAR_VERTICAL_POS_REM, player.currentCarBottomRem + CAR_VERTICAL_SPEED_STEP_REM); 
            player.car.style.bottom = player.currentCarBottomRem + "vmin";
            // Ajustar la posición del nombre del jugador junto con el coche.
            if (player.nameDisplay) {
                player.nameDisplay.style.left = (player.currentCarPosPx + (carWidth / 2)) + "px";
                player.nameDisplay.style.bottom = (player.currentCarBottomRem + 7) + "vmin"; 
            }
        }
    }

    /**
     * Desacelera la velocidad general del juego y mueve visualmente el coche del jugador hacia abajo en la pantalla.
     */
    function decelerate() {
        if (gamePaused) return;
        gameSpeedMultiplier = Math.max(MIN_GAME_SPEED_MULTIPLIER, gameSpeedMultiplier - SPEED_CHANGE_STEP);
        updateCSSAnimationsSpeed(); // Actualizar animaciones CSS para reflejar la nueva velocidad.

        const player = players[gameRound];
        if (player.car) {
            const carWidth = player.car.offsetWidth; // Define carWidth here
            // Mover el coche hacia abajo (hacia el máximo 'bottom' vmin).
            player.currentCarBottomRem = Math.max(MAX_CAR_VERTICAL_POS_REM, player.currentCarBottomRem - CAR_VERTICAL_SPEED_STEP_REM); 
            player.car.style.bottom = player.currentCarBottomRem + "vmin";
            // Ajustar la posición del nombre del jugador junto con el coche.
            if (player.nameDisplay) {
                player.nameDisplay.style.left = (player.currentCarPosPx + (carWidth / 2)) + "px";
                player.nameDisplay.style.bottom = (player.currentCarBottomRem + 7) + "vmin"; 
            }
        }
    }

    /**
     * Mueve el coche del jugador lateralmente dentro de su carril.
     * @param {string} direction - La dirección del movimiento ('left' o 'right').
     * @param {number} playerIndex - El índice del jugador cuyo coche se va a mover.
     */
    function moveCar(direction, playerIndex) {
        // No permitir movimiento si el juego está pausado o los controles de dirección están inactivos.
        if (gamePaused || (unifiedControlsRow && unifiedControlsRow.classList.contains('inactive-controls'))) {
            return;
        }

        const player = players[playerIndex];
        // Validar que el jugador, su coche y su carril existan.
        if (!player || !player.car || !player.laneElement) {
            return;
        }
        // En modo de dos jugadores, solo el jugador actual puede mover su coche.
        if (gameMode === 'twoPlayers' && playerIndex !== gameRound) {
            return;
        }

        const carWidth = player.car.offsetWidth;
        const laneWidth = player.laneElement.offsetWidth;
        let newCarPosPx = player.currentCarPosPx;

        // Calcular la nueva posición horizontal del coche.
        if (direction === 'left') {
            newCarPosPx -= ADJUSTED_CAR_MOVEMENT_SPEED; 
        } else if (direction === 'right') {
            newCarPosPx += ADJUSTED_CAR_MOVEMENT_SPEED; 
        }

        // Limitar la posición del coche dentro de los límites del carril.
        const minCarPosPx = 0;
        const maxCarPosPx = laneWidth - carWidth;
        newCarPosPx = Math.max(minCarPosPx, Math.min(newCarPosPx, maxCarPosPx));

        player.car.style.left = newCarPosPx + "px";
        player.currentCarPosPx = newCarPosPx;

        // Actualizar la posición del nombre del jugador para que siga al coche.
        if (player.nameDisplay) {
            player.nameDisplay.style.left = (player.currentCarPosPx + (carWidth / 2)) + "px";
            player.nameDisplay.style.bottom = (player.currentCarBottomRem + 7) + "vmin"; 
        }
    }

    /**
     * Crea el personaje KilleRRacing y lo añade a la pista de juego.
     * Rol: KilleRRacing es un personaje hostil que el jugador debe esquivar.
     * Su aparición y velocidad varían según el nivel de dificultad. Si colisiona, el juego termina.
     */
    function createKillerRacing() {
        if (gamePaused || killeRacingInstance || isKillerRacingAttacking) return; // No crear si el juego está pausado o ya hay una instancia o está en modo ataque.

        const kr = document.createElement("div");
        kr.classList.add("kille-racing");
        
        const targetLane = document.getElementById('player1-lane');
        if (!targetLane) return;

        targetLane.appendChild(kr); 

        const laneHeight = targetLane.offsetHeight;
        const krHeight = kr.offsetHeight;
        const laneWidth = targetLane.offsetWidth;
        const krWidth = kr.offsetWidth;

        // **Implementación de salida aleatoria (der=>izq o izq=>der)**
        killeRacingState.initialDirection = Math.random() < 0.5 ? 'left' : 'right';

        if (killeRacingState.initialDirection === 'left') {
            kr.style.left = `${laneWidth}px`; // Inicia en el borde derecho.
            kr.style.transform = 'scaleX(-1)'; // Mira a la izquierda.
        } else { // 'right'
            kr.style.left = `${-krWidth}px`; // Inicia en el borde izquierdo (fuera de pantalla).
            kr.style.transform = 'scaleX(1)'; // Mira a la derecha.
        }
        kr.style.top = `${-krHeight}px`; // Inicia fuera de la pantalla por arriba.
        
        killeRacingInstance = kr;
        killeRacingInstance.dataset.currentTop = parseFloat(kr.style.top); // Almacenar posición inicial.
        killeRacingInstance.dataset.currentLeft = parseFloat(kr.style.left); // Almacenar posición inicial.
        killeRacingHorizontalDirection = killeRacingState.initialDirection;

        // Ocupar ambos carriles para KilleRRacing (impide que otros objetos aparezcan).
        laneOccupancy.left = true;
        laneOccupancy.right = true;

        // **Implementación de velocidad variable según el nivel**
        let initialSpeed;
        if (currentLevel === 'principiante') {
            initialSpeed = KILLER_RACER_BASE_SPEED;
            killeRacingState.initialSpeedType = 'normal'; // Siempre normal en principiante.
        } else { // Novato y Experto
            killeRacingState.initialSpeedType = Math.random() < 0.5 ? 'normal' : 'accelerated';
            if (killeRacingState.initialSpeedType === 'normal') {
                initialSpeed = KILLER_RACER_BASE_SPEED;
            } else {
                initialSpeed = KILLER_RACER_BASE_SPEED * KILLER_RACER_ACCELERATED_SPEED_MULTIPLIER;
            }
        }
        killeRacingState.currentSpeed = initialSpeed;
        killeRacingState.midLanePoint = (laneWidth / 2); // Punto medio del carril para cambios de velocidad.
        killeRacingState.speedChangedMidLane = false; // Resetear la bandera de cambio de velocidad a mitad de carril.

        // En nivel experto, KilleRRacing se genera en el centro.
        if (currentLevel === 'experto') {
            kr.style.left = calculateHorizontalPositionInLane(targetLane, krWidth, 'center-lane') + "px";
            killeRacingInstance.dataset.currentLeft = parseFloat(kr.style.left);
            // Para Experto, la dirección inicial de "escape" es aleatoria desde el centro
            killeRacingHorizontalDirection = Math.random() < 0.5 ? 'left' : 'right';
            kr.style.transform = (killeRacingHorizontalDirection === 'left') ? 'scaleX(-1)' : 'scaleX(1)';
        }

        killeRacingAnimId = requestAnimationFrame(moveKillerRacing); // Iniciar la animación de KilleRRacing.

        // KilleRRacing siempre fuerza una transición a la fase de sumas al aparecer,
        // ya que es un evento disruptivo y queremos que el juego vuelva a su flujo normal después.
        currentPhase = 'sums';
        sumsCountForCurrentPhase = Math.floor(Math.random() * (SUMS_PER_OBJECT_PHASE_MAX - SUMS_PER_OBJECT_PHASE_MIN + 1)) + SUMS_PER_OBJECT_PHASE_MIN;
        currentSumsGeneratedInPhase = 0;
        objectGeneratedThisPhase = false; // Resetear para la próxima fase de objetos.
        operationsAnsweredSinceLastKilleRacing = 0; // Reiniciar contador de operaciones para la próxima aparición.
        
        // Detener y reiniciar los intervalos de generación de sumas y árboles para sincronizar con la nueva fase.
        if (createSumInterval) clearInterval(createSumInterval);
        createSumInterval = setInterval(createSum, SUM_CREATION_INTERVAL);
        
        if (generateSimpleSumsInterval) {
            clearInterval(generateSimpleSumsInterval);
            generateSimpleSumsInterval = null;
            isBarrierEffectActive = false; // KilleRRacing anula el efecto de barrera si estaba activo.
        }

        console.log("DEBUG: KilleRRacing creado. Fase restablecida a 'sums'.");
    }

    /**
     * Mueve el personaje KilleRRacing horizontal y verticalmente en la pantalla.
     * Implementa la lógica de volteo horizontal al colisionar con los bordes laterales
     * y los cambios de velocidad para los niveles Novato y Experto.
     */
    function moveKillerRacing() {
        if (gamePaused || !killeRacingInstance) {
            killeRacingAnimId = null; 
            return;
        }

        let currentTop = parseFloat(killeRacingInstance.dataset.currentTop);
        let currentLeft = parseFloat(killeRacingInstance.dataset.currentLeft);
        
        const targetLane = document.getElementById('player1-lane');
        if (!targetLane) { 
            killeRacingAnimId = null;
            return;
        }

        const krWidth = killeRacingInstance.offsetWidth;
        const krHeight = killeRacingInstance.offsetHeight;
        const laneWidth = targetLane.offsetWidth;
        const laneHeight = targetLane.offsetHeight;

        // Movimiento vertical (caída).
        currentTop += (killeRacingState.currentSpeed * gameSpeedMultiplier);

        // Movimiento horizontal y volteo.
        // Implementación de velocidad variable para Novato y Experto.
        if (currentLevel !== 'principiante') {
            const hasCrossedMidPoint = (killeRacingHorizontalDirection === 'left' && currentLeft <= killeRacingState.midLanePoint) ||
                                       (killeRacingHorizontalDirection === 'right' && (currentLeft + krWidth) >= killeRacingState.midLanePoint);
            
            // Si KilleRRacing ha cruzado el punto medio y no ha cambiado de velocidad aún en este "tramo".
            if (hasCrossedMidPoint && !killeRacingState.speedChangedMidLane) {
                if (killeRacingState.initialSpeedType === 'normal') {
                    killeRacingState.currentSpeed = KILLER_RACER_BASE_SPEED * KILLER_RACER_ACCELERATED_SPEED_MULTIPLIER;
                    killeRacingState.isAccelerating = true;
                } else { // initialSpeedType === 'accelerated'
                    killeRacingState.currentSpeed = KILLER_RACER_BASE_SPEED;
                    killeRacingState.isAccelerating = false;
                }
                killeRacingState.speedChangedMidLane = true; // Marcar que la velocidad ya cambió.
            } else if (!hasCrossedMidPoint && killeRacingState.speedChangedMidLane) {
                // Resetear la bandera si KilleRRacing se aleja del punto medio, preparándolo para el próximo cambio.
                killeRacingState.speedChangedMidLane = false;
            }
        }

        if (killeRacingHorizontalDirection === 'left') {
            currentLeft -= (killeRacingState.currentSpeed * gameSpeedMultiplier);
            // Si choca con el borde izquierdo, voltea y cambia de dirección.
            if (currentLeft <= 0) {
                currentLeft = 0; // Asegura que no se salga.
                killeRacingHorizontalDirection = 'right';
                killeRacingInstance.style.transform = 'scaleX(1)'; // Mirar a la derecha.
                killeRacingState.speedChangedMidLane = false; // Resetear bandera de cambio de velocidad.
            }
        } else { // direction === 'right'
            currentLeft += (killeRacingState.currentSpeed * gameSpeedMultiplier);
            // Si choca con el borde derecho, voltea y cambia de dirección.
            if (currentLeft + krWidth >= laneWidth) {
                currentLeft = laneWidth - krWidth; // Asegura que no se salga.
                currentLeft = laneWidth - krWidth; // Asegura que no se salga.
                killeRacingHorizontalDirection = 'left';
                killeRacingInstance.style.transform = 'scaleX(-1)'; // Mirar a la izquierda.
                killeRacingState.speedChangedMidLane = false; // Resetear bandera de cambio de velocidad.
            }
        }

        killeRacingInstance.style.top = `${currentTop}px`;
        killeRacingInstance.style.left = `${currentLeft}px`;
        killeRacingInstance.dataset.currentTop = currentTop; // Actualizar datos para la próxima iteración.
        killeRacingInstance.dataset.currentLeft = currentLeft; // Actualizar datos para la próxima iteración.

        // Si KilleRRacing ha salido completamente por la parte inferior, eliminarlo y liberar carriles.
        if (currentTop >= laneHeight) {
            if (killeRacingInstance.parentNode) {
                killeRacingInstance.parentNode.removeChild(killeRacingInstance);
            }
            cancelAnimationFrame(killeRacingAnimId);
            killeRacingInstance = null; 
            killeRacingAnimId = null;
            laneOccupancy.left = false; // Liberar ambos carriles.
            laneOccupancy.right = false;
        } else {
            killeRacingAnimId = requestAnimationFrame(moveKillerRacing); // Solicitar el siguiente frame.
        }
    }

    /**
     * Comprueba si el coche del jugador actual colisiona con alguna de las sumas, pits, barreras, huecos o KilleRRacing.
     * Si se detecta una colisión, se llama al manejador correspondiente.
     */
    function checkCollisions() {
        if (gamePaused) return;

        const activePlayer = players[gameRound];
        if (!activePlayer || !activePlayer.car) return;

        const playerCarRect = activePlayer.car.getBoundingClientRect(); // Obtener las dimensiones y posición del coche.
        
        // Función auxiliar para verificar y manejar colisiones con múltiples elementos.
        const checkAndHandleCollision = (elements, type, handler) => {
            elements.forEach(el => {
                // Evitar colisiones repetidas con el mismo elemento si ya fue marcado como colisionado.
                if (el.dataset.collided === 'true') return;

                const rect = el.getBoundingClientRect(); // Obtener las dimensiones y posición del elemento.
                // Lógica de detección de colisión simple (overlapping rectangles).
                if (
                    playerCarRect.top <= rect.bottom &&
                    playerCarRect.bottom >= rect.top &&
                    playerCarRect.left < rect.right &&
                    playerCarRect.right > rect.left
                ) {
                    el.dataset.collided = 'true'; // Marcar el elemento como colisionado.
                    handler(el, players.indexOf(activePlayer)); // Ejecutar el manejador específico del tipo de objeto.
                }
            });
        };

        // Verificar colisiones con sumas matemáticas.
        checkAndHandleCollision(document.querySelectorAll(`.suma-caida[data-player-id="${activePlayer.id}"]`), 'sum', (sumElement) => {
            currentCollidingSum = sumElement;
            currentCollidingSum.dataset.collisionStartTime = Date.now(); // Registrar el tiempo de colisión.

            // Lógica de KilleRRacing atacando la operación para Novato y Experto
            if (currentLevel === 'novato' || currentLevel === 'experto') {
                // Si es la primera operación, NO atacar, solo registrar el tiempo.
                if (activePlayer.sumsAnsweredInRound === 0) {
                    console.log("DEBUG: Primera operación para el jugador. No hay ataque de KilleRRacing.");
                    
                    // Mover la suma a la parte inferior centrada de la pista
                    const playerLane = document.getElementById('player1-lane');
                    const laneWidth = playerLane.offsetWidth;
                    const sumWidth = sumElement.offsetWidth;
                    const sumHeight = sumElement.offsetHeight;
                    
                    // Reposicionar la suma al final de la línea segmentada (parte inferior de player1-lane)
                    sumElement.style.left = `${(laneWidth / 2) - (sumWidth / 2)}px`;
                    sumElement.style.top = `${playerLane.offsetHeight - sumHeight - 10}px`; // 10px de margen sobre el final del carril
                    
                    currentCollidingSum.classList.add('colliding-highlight'); // Resaltar la suma colisionada.
                    pauseGame(); // Pausar el juego para que el jugador pueda responder.
                    setDirectionalControlsActive(false); // Desactivar controles de dirección.
                    setInputControlsActive(true); // Activar controles de entrada de respuesta.
                    if (commonControls.answerBox) {
                        commonControls.answerBox.focus(); // Poner el foco en la caja de respuesta.
                    }
                } else {
                    // Para operaciones posteriores, iniciar el ataque.
                    startKillerRacingAttack(sumElement); // Inicia el ataque de KilleRRacing
                }
            } else {
                // Comportamiento normal para Principiante (sin ataque de KilleRRacing a la operación)
                currentCollidingSum.classList.add('colliding-highlight'); // Resaltar la suma colisionada.
                pauseGame(); // Pausar el juego para que el jugador pueda responder.
                setDirectionalControlsActive(false); // Desactivar controles de dirección.
                setInputControlsActive(true); // Activar controles de entrada de respuesta.
                if (commonControls.answerBox) {
                    commonControls.answerBox.focus(); // Poner el foco en la caja de respuesta.
                }
            }
        });
        // Verificar colisiones con Pits.
        checkAndHandleCollision(document.querySelectorAll(`.pit[data-player-id="${activePlayer.id}"]`), 'pit', handlePitCollision);
        // Verificar colisiones con Barreras.
        checkAndHandleCollision(document.querySelectorAll(`.slowdown-strip[data-player-id="${activePlayer.id}"]`), 'slowdown-strip', handleSlowdownStripCollision);
        // Verificar colisiones con Huecos.
        checkAndHandleCollision(document.querySelectorAll(`.hueco[data-player-id="${activePlayer.id}"]`), 'hueco', handleHoleCollision);

        // Verificar colisión con KilleRRacing mismo (se maneja por separado por su lógica única).
        if (killeRacingInstance && killeRacingInstance.dataset.collided !== 'true') {
            const killeRacingRect = killeRacingInstance.getBoundingClientRect();
            if (
                playerCarRect.top <= killeRacingRect.bottom &&
                playerCarRect.bottom >= killeRacingRect.top &&
                playerCarRect.left < killeRacingRect.right &&
                playerCarRect.right > killeRacingRect.left
            ) {
                killeRacingInstance.dataset.collided = 'true'; // Marcar KilleRRacing como colisionado.
                handleKillerRacingCollision(players.indexOf(activePlayer)); // Ejecutar el manejador de colisión de KilleRRacing.
            }
        }
    }

    /**
     * Muestra un mensaje temporal de retroalimentación de colisión en la pantalla del juego.
     * @param {string} message - El texto del mensaje a mostrar.
     * @param {DOMRect} rect - El `getBoundingClientRect()` del elemento colisionado (para posicionar el mensaje).
     * @param {HTMLElement} parentElement - El elemento padre donde se añadirá el mensaje.
     */
    function showCollisionFeedbackMessage(message, rect, parentElement) {
        const feedbackDiv = document.createElement('div');
        feedbackDiv.classList.add('collision-feedback-message');
        feedbackDiv.textContent = message;

        // Posicionar el mensaje de retroalimentación en el centro del elemento colisionado.
        feedbackDiv.style.left = `${rect.left + rect.width / 2}px`;
        feedbackDiv.style.top = `${rect.top + rect.height / 2}px`;
        feedbackDiv.style.transform = 'translate(-50%, -50%)';

        parentElement.appendChild(feedbackDiv);

        // Eliminar el mensaje después de un tiempo definido.
        setTimeout(() => {
            feedbackDiv.remove();
        }, COLLISION_FEEDBACK_MESSAGE_DURATION);
    }

    /**
     * Maneja la colisión del jugador con un elemento Pit.
     * Rol: Otorga puntos y puede "reparar" una luz roja (respuesta incorrecta) en una luz amarilla.
     */
    function handlePitCollision(pitElement, playerIndex) {
        const player = players[playerIndex];
        if (!player) return;

        let awardedPitPoints = 0;
        let redLightFoundAndConverted = false;
        
        // Iterar desde el final para encontrar la última luz roja y convertirla en amarilla.
        for (let i = globalOperationsFeedbackLights.length - 1; i >= 0; i--) {
            if (globalOperationsFeedbackLights[i].classList.contains('red')) {
                globalOperationsFeedbackLights[i].classList.remove('red', 'green');
                globalOperationsFeedbackLights[i].classList.add('yellow'); 
                // Ajuste del contador de sumas respondidas para reflejar la "reparación" de la luz.
                // No se modifica player.sumsAnsweredInRound aquí, ya que solo se cambia el color de la luz.
                awardedPitPoints = PITS_POINTS_AWARDED_WITH_RED_LIGHTS; 
                redLightFoundAndConverted = true;
                break; // Una vez que encontramos y cambiamos una luz roja, salimos del bucle.
            }
        }

        // Si no se encontró ninguna luz roja para convertir, se acumula un Pit para uso futuro.
        if (!redLightFoundAndConverted) {
            player.pitsAvailable++; // Incrementa los Pits disponibles para futuras correcciones.
            awardedPitPoints = PITS_POINTS_AWARDED_NO_RED_LIGHTS; // Se otorgan puntos por recoger el Pit "limpio".
            console.log(`DEBUG: ${player.name} recogió un Pit (sin errores). Pits disponibles: ${player.pitsAvailable}, Puntos de Pits: ${player.pitsPoints + awardedPitPoints}`);
        } else {
            // Si se encontró y corrigió una luz roja, los puntos ya fueron asignados en el bucle.
            console.log(`DEBUG: ${player.name} usó un Pit para corregir un error pasado. Pits disponibles: ${player.pitsAvailable}, Puntos de Pits: ${player.pitsPoints + awardedPitPoints}`);
        }

        player.pitsPoints += awardedPitPoints; // Añadir puntos de Pit al jugador.

        // Actualizar la visualización de los Pits disponibles (ahora en globalPitsPointsDisplay).
        if (globalPitsPointsDisplay) {
            globalPitsPointsDisplay.textContent = player.pitsAvailable.toString().padStart(3, '0');
        }
        // No se cambia globalScoreDisplay ya que rastrea los puntos de operación.

        // Remover el Pit de la pantalla y liberar su animación.
        if (pitElement.parentNode) {
            pitElement.parentNode.removeChild(pitElement);
            activeRAFAnimations.delete(pitElement); 
        }
        // Liberar el carril que ocupaba el Pit.
        if (pitElement.dataset.subLane) {
            laneOccupancy[pitElement.dataset.subLane] = false;
        }
    }

    /**
     * Maneja la colisión del jugador con un elemento Hueco.
     * Rol: Penaliza al jugador quitando puntos y convirtiendo una luz verde (respuesta correcta) en una roja.
     * @param {HTMLElement} holeElement - El elemento Hueco con el que se colisionó.
     * @param {number} playerIndex - El índice del jugador que golpeó el Hueco.
     */
    function handleHoleCollision(holeElement, playerIndex) {
        const player = players[playerIndex];
        if (!player) return;

        const holeRect = holeElement.getBoundingClientRect();
        showCollisionFeedbackMessage("¡UUY! -1", holeRect, gameAreaContainer); // Mostrar mensaje de penalización.

        let foundGreenLightAndConverted = false;
        // Iterar para encontrar la primera luz verde y convertirla en roja.
        for (let i = 0; i < globalOperationsFeedbackLights.length; i++) {
            if (globalOperationsFeedbackLights[i].classList.contains('green')) {
                globalOperationsFeedbackLights[i].classList.remove('green');
                globalOperationsFeedbackLights[i].classList.add('red'); 
                player.correctAnswers = Math.max(0, player.correctAnswers - 1); // Decrementar respuestas correctas.
                foundGreenLightAndConverted = true;
                break;
            }
        }

        player.score = Math.max(0, player.score - HOLE_SCORE_PENALTY); // Restar puntos por la colisión.
        // Actualizar la visualización de la puntuación global.
        if (globalScoreDisplay) {
            globalScoreDisplay.textContent = player.score.toString().padStart(3, '0');
        }

        // Remover el Hueco de la pantalla y liberar su animación.
        if (holeElement.parentNode) {
            holeElement.parentNode.removeChild(holeElement);
            activeRAFAnimations.delete(holeElement);
        }
        // Liberar el carril que ocupaba el Hueco.
        if (holeElement.dataset.subLane) {
            laneOccupancy[holeElement.dataset.subLane] = false;
        }
    }

    /**
     * Maneja la colisión del jugador con el personaje KilleRRacing (en la pista).
     * Rol: KilleRRacing es un evento "Game Over" si colisiona con el jugador.
     * El juego se detiene y se muestra un mensaje.
     * @param {number} playerIndex - El índice del jugador que colisionó con KilleRRacing.
     */
    function handleKillerRacingCollision(playerIndex) {
        const player = players[playerIndex];
        if (!player) return;
        
        pauseGame(); // Pausar el juego.
        setDirectionalControlsActive(false); // Desactivar todos los controles.
        setInputControlsActive(false);

        // Remover la instancia de KilleRRacing de la pantalla y detener sus animaciones.
        if (killeRacingInstance && killeRacingInstance.parentNode) {
            if (killeRacingAnimId) {
                cancelAnimationFrame(killeRacingAnimId);
                killeRacingAnimId = null;
            }
            if (killeRacingInstance.parentNode) {
                killeRacingInstance.parentNode.removeChild(killeRacingInstance);
            }
            killeRacingInstance = null; 
            laneOccupancy.left = false; // Liberar ambos carriles que ocupaba KilleRRacing.
            laneOccupancy.right = false;
        }

        // Formato del mensaje de KilleRRacing con salto de línea y parpadeo.
        showMessage(`
            <img src="https://i.postimg.cc/SNCjdmF9/Math-Killer.png" alt="KilleRRacing" style="max-width: 100px; margin-bottom: 10px; filter: drop-shadow(0 0 8px yellow) drop-shadow(0 0 15px yellow);" />
            <br>KilleRRacing
            <br>¡Has Muerto!
            <br><span class='blinking-text'>JA, JA, JA, JA.</span>
        `); 
    }

    /**
     * Procesa la respuesta numérica introducida por el usuario después de colisionar con una suma.
     * Compara la respuesta del jugador con la respuesta correcta y actualiza la puntuación y el feedback.
     * @param {string} playerId - El ID del jugador que envió la respuesta.
     */
    function processAnswer(playerId) {
        const player = players.find(p => p.id === playerId);
        
        // Si no hay jugador o suma colisionada, o si el juego está pausado sin una suma en colisión, reanudar.
        if (!player || !currentCollidingSum) {
            if (commonControls.answerBox) commonControls.answerBox.value = '';
            if (gamePaused && currentCollidingSum === null && !isKillerRacingAttacking) { // Solo reanudar si no hay ataque de KR
                resumeGame(); 
                setDirectionalControlsActive(true);
                setInputControlsActive(false);
            }
            return;
        }

        let userAnswerValue = commonControls.answerBox.value.trim();
        
        const userAnswer = parseInt(userAnswerValue);
        
        // Si la respuesta está vacía o no es un número, limpiar y salir.
        if (userAnswerValue === '' || isNaN(userAnswer)) { 
            if (commonControls.answerBox) commonControls.answerBox.value = '';
            return; 
        }
        
        // Asegurarse de que la suma colisionada pertenece al jugador actual (relevante en multijugador futuro).
        if (currentCollidingSum.dataset.playerId !== playerId) {
            if (commonControls.answerBox) commonControls.answerBox.value = ''; 
            return;
        }
        
        const correctAnswer = parseInt(currentCollidingSum.dataset.respuesta);
        const pointsEarned = parseInt(currentCollidingSum.dataset.valorPuntos);
        const sumDifficulty = currentCollidingSum.dataset.sumDifficulty;

        if (commonControls.answerBox) {
            commonControls.answerBox.value = ''; 
        }
        setInputControlsActive(false); // Desactivar la entrada mientras se procesa la respuesta.

        // Si es la primera operación, registrar el tiempo de respuesta.
        if (player.sumsAnsweredInRound === 0 && (currentLevel === 'novato' || currentLevel === 'experto')) {
            player.firstResponseTime = Date.now() - parseInt(currentCollidingSum.dataset.collisionStartTime);
            console.log(`DEBUG: Tiempo de primera respuesta para ${player.name}: ${player.firstResponseTime}ms`);
        }

        if (userAnswer !== correctAnswer) { // Respuesta Incorrecta
            // NUEVA LÓGICA: Si el jugador tiene Pits disponibles, los usa para corregir el error.
            if (player.pitsAvailable > 0) {
                player.pitsAvailable--; // Consume un Pit disponible
                player.score += pointsEarned; // Otorga los puntos de la operación
                player.incorrectAnswers++; // Aún cuenta como respuesta incorrecta en el récord
                updateLightbulbs(gameRound, true); // La luz se vuelve VERDE (como si fuera correcta)
                showCollisionFeedbackMessage("Usas un Pits", currentCollidingSum.getBoundingClientRect(), gameAreaContainer); // Mensaje de feedback
                console.log(`DEBUG: ${player.name} usó un Pit para corregir un error. Pits restantes: ${player.pitsAvailable}`);

                // Actualizar la visualización de los Pits disponibles
                if (globalPitsPointsDisplay) {
                    globalPitsPointsDisplay.textContent = player.pitsAvailable.toString().padStart(3, '0');
                }
                // Actualizar la visualización de la puntuación
                if (globalScoreDisplay) {
                    globalScoreDisplay.textContent = player.score.toString().padStart(3, '0');
                }

                // Remover la suma después de una pequeña animación de explosión
                currentCollidingSum.classList.add('explode');
                setTimeout(() => {
                    if (currentCollidingSum) {
                        currentCollidingSum.classList.remove('colliding-highlight');
                        if (currentCollidingSum.parentNode) {
                            currentCollidingSum.parentNode.removeChild(currentCollidingSum);
                            activeRAFAnimations.delete(currentCollidingSum);
                        }
                    }
                    currentCollidingSum = null;
                    player.sumsAnsweredInRound++; // Incrementa el contador para la progresión del juego

                    // Verificar si se ha alcanzado el final del turno/juego
                    if (player.sumsAnsweredInRound >= currentMaxAnsweredSums) {
                        handlePlayerTurnEnd();
                    } else {
                        resumeGame(); // Reanudar el juego
                        setDirectionalControlsActive(true); // Activar controles de dirección
                    }
                    // Lógica de KilleRRacing (se aplica ya que la operación fue "respondida")
                    if (currentLevel !== 'principiante' && killeRacingInstance === null && !isKillerRacingAttacking) {
                        let operationsThreshold = (currentLevel === 'novato') ? KILLER_RACER_SPAWN_OPERATIONS_NOVATO : KILLER_RACER_SPAWN_OPERATIONS_EXPERTO;
                        if (operationsAnsweredSinceLastKilleRacing >= operationsThreshold) {
                            createKillerRacing();
                            operationsAnsweredSinceLastKilleRacing = 0;
                        }
                    }
                }, CORRECT_ANSWER_EXPLOSION_TIME);

            } else { // No hay Pits disponibles, procede con la lógica normal de respuesta incorrecta
                // Si no es una suma sencilla de barrera, registra como incorrecta y actualiza luces.
                if (sumDifficulty !== 'sencilla-barrera') { 
                    player.incorrectAnswers++;
                    updateLightbulbs(gameRound, false); // Actualiza la luz a roja.
                    if (!isKillerRacingAttacking) {
                        operationsAnsweredSinceLastKilleRacing++; 
                        console.log(`DEBUG: Operaciones respondidas para KilleRRacing: ${operationsAnsweredSinceLastKilleRacing}`);
                    }
                } else {
                    // Si es una suma sencilla de barrera y es incorrecta, decrementa el contador.
                    barrierSimpleSumsCounter--;
                    if (barrierSimpleSumsCounter <= 0) { // Si el contador llega a 0, intenta finalizar el efecto.
                         endBarrierEffect();
                    }
                }

                currentCollidingSum.textContent = correctAnswer; // Muestra la respuesta correcta.
                currentCollidingSum.classList.add('incorrect-answer-feedback'); // Aplica estilo de feedback incorrecto.
                
                // Finalizar ataque de KilleRRacing si estaba activo (respuesta incorrecta)
                if (isKillerRacingAttacking) {
                    endKillerRacingAttack(currentCollidingSum, false); // La suma no fue respondida a tiempo
                    return; // Salir para que endKillerRacingAttack maneje el flujo
                }

                // Retraso para mostrar el feedback antes de remover la suma.
                setTimeout(() => {
                    if (currentCollidingSum) {
                        currentCollidingSum.classList.remove('colliding-highlight');
                        if (currentCollidingSum.parentNode) {
                            currentCollidingSum.parentNode.removeChild(currentCollidingSum);
                            activeRAFAnimations.delete(currentCollidingSum);
                        }
                    }
                    currentCollidingSum = null;
                    
                    // Solo incrementa sumsAnsweredInRound si no es una suma sencilla de barrera.
                    if (sumDifficulty !== 'sencilla-barrera') {
                        player.sumsAnsweredInRound++;
                    }

                    // Si se han respondido suficientes sumas en la ronda, termina el turno o el juego.
                    if (player.sumsAnsweredInRound >= currentMaxAnsweredSums) { 
                        handlePlayerTurnEnd();
                    } else {
                        resumeGame(); // Reanudar el juego.
                        setDirectionalControlsActive(true); // Activar controles de dirección.
                    }

                    // **Nueva lógica de aparición de KilleRRacing para Novato/Experto (basada en operaciones respondidas)**
                    if (currentLevel !== 'principiante' && killeRacingInstance === null && !isKillerRacingAttacking) { // Asegurarse de que no esté en modo ataque
                        let operationsThreshold = (currentLevel === 'novato') ? KILLER_RACER_SPAWN_OPERATIONS_NOVATO : KILLER_RACER_SPAWN_OPERATIONS_EXPERTO;
                        if (operationsAnsweredSinceLastKilleRacing >= operationsThreshold) {
                            createKillerRacing();
                            operationsAnsweredSinceLastKilleRacing = 0; // Reiniciar contador.
                        }
                    }
                }, INCORRECT_ANSWER_FEEDBACK_TIME); 
            }
            
        } else { // Respuesta Correcta
            player.score += pointsEarned; // Añadir puntos.
            
            // Si no es una suma sencilla de barrera, registra como correcta y actualiza luces.
            if (sumDifficulty !== 'sencilla-barrera') {
                player.correctAnswers++;
                updateLightbulbs(gameRound, true); // Actualiza la luz a verde.
                // SOLO incrementar operationsAnsweredSinceLastKilleRacing si NO está en modo ataque
                if (!isKillerRacingAttacking) {
                    operationsAnsweredSinceLastKilleRacing++; 
                    console.log(`DEBUG: Operaciones respondidas para KilleRRacing: ${operationsAnsweredSinceLastKilleRacing}`);
                }
            } else {
                // Si es una suma sencilla de barrera y es correcta, decrementa el contador.
                barrierSimpleSumsCounter--;
                if (barrierSimpleSumsCounter <= 0) { // Si el contador llega a 0, intenta finalizar el efecto.
                    endBarrierEffect();
                }
            }
            
            // Actualizar la visualización de la puntuación.
            if (globalScoreDisplay) {
                globalScoreDisplay.textContent = player.score.toString().padStart(3, '0');
            }
            // No se cambia globalPitsPointsDisplay aquí.

            currentCollidingSum.classList.add('explode'); // Aplica animación de explosión.

            // Finalizar ataque de KilleRRacing si estaba activo (respuesta correcta)
            if (isKillerRacingAttacking) {
                endKillerRacingAttack(currentCollidingSum, true); // La suma fue respondida a tiempo
            }
            
            // Retraso para la animación de explosión antes de remover la suma.
            setTimeout(() => {
                if (currentCollidingSum) {
                    currentCollidingSum.classList.remove('colliding-highlight');
                    if (currentCollidingSum.parentNode) {
                        currentCollidingSum.parentNode.removeChild(currentCollidingSum);
                        activeRAFAnimations.delete(currentCollidingSum);
                    }
                }
                currentCollidingSum = null;

                // Aumentar la velocidad de caída de sumas si la puntuación es un múltiplo de ANSWERS_TO_INCREASE_SPEED.
                if (player.score > 0 && player.score % ANSWERS_TO_INCREASE_SPEED === 0) {
                    let baseSpeedForIncrease = 0;
                    switch(currentLevel) {
                        case 'principiante': baseSpeedForIncrease = 1.5; break; 
                        case 'novato': baseSpeedForIncrease = 2.25; break;
                        case 'experto': baseSpeedForIncrease = 3; break;
                    }
                    
                    baseSpeedForIncrease += ADJUSTED_SUM_SPEED_INCREASE_VALUE;

                    const currentLaneHeight = player.laneElement.offsetHeight; 
                    const maxSpeedAdjusted = MAX_SUM_SPEED * (currentLaneHeight / BASE_ROAD_HEIGHT);

                    player.currentSumSpeed = Math.min(baseSpeedForIncrease * (currentLaneHeight / BASE_ROAD_HEIGHT), maxSpeedAdjusted);
                }
                
                // Solo incrementa sumsAnsweredInRound si no es una suma sencilla de barrera.
                if (sumDifficulty !== 'sencilla-barrera') {
                    player.sumsAnsweredInRound++;
                }

                // Si se han respondido suficientes sumas en la ronda, termina el turno o el juego.
                if (player.sumsAnsweredInRound >= currentMaxAnsweredSums) { 
                    handlePlayerTurnEnd();
                } else {
                    // Solo reanudar el juego si no hay un ataque de KilleRRacing pendiente
                    if (!isKillerRacingAttacking) {
                        resumeGame(); // Reanudar el juego.
                        setDirectionalControlsActive(true); // Activar controles de dirección.
                    }
                }

                // **Nueva lógica de aparición de KilleRRacing para Novato/Experto (basada en operaciones respondidas)**
                if (currentLevel !== 'principiante' && killeRacingInstance === null && !isKillerRacingAttacking) {
                    let operationsThreshold = (currentLevel === 'novato') ? KILLER_RACER_SPAWN_OPERATIONS_NOVATO : KILLER_RACER_SPAWN_OPERATIONS_EXPERTO;
                    if (operationsAnsweredSinceLastKilleRacing >= operationsThreshold) {
                        createKillerRacing();
                        operationsAnsweredSinceLastKilleRacing = 0; // Reiniciar contador.
                    }
                }
            }, CORRECT_ANSWER_EXPLOSION_TIME); 
        }
    }

    /**
     * Actualiza el estado visual de las "luces" de feedback de operaciones (semáforos) para el jugador actual.
     * @param {number} playerIndex - El índice del jugador actual.
     * @param {boolean} isCorrect - True si la última respuesta fue correcta (luz verde), false si fue incorrecta (luz roja).
     */
    function updateLightbulbs(playerIndex, isCorrect) {
        const player = players[playerIndex];
        const lightIndex = player.sumsAnsweredInRound; // Usa el contador de sumas respondidas para el índice de la luz.

        if (lightIndex >= 0 && lightIndex < globalOperationsFeedbackLights.length) {
            const lightElement = globalOperationsFeedbackLights[lightIndex];
            lightElement.classList.remove('yellow', 'green', 'red'); // Remover clases existentes.
            if (isCorrect) {
                lightElement.classList.add('green'); // Añadir clase verde.
            } else {
                lightElement.classList.add('red'); // Añadir clase roja.
            }
        }
    }

    /**
     * Limpia todos los elementos dinámicos del juego de la pantalla (sumas, pits, barreras, huecos, árboles).
     * También elimina a KilleRRacing si está presente y reinicia los estados de ocupación de carriles.
     */
    function clearGameElements() {
        document.querySelectorAll('.suma-caida, .arbol, .pit, .slowdown-strip, .hueco').forEach(el => {
            if (activeRAFAnimations.has(el)) { // Cancelar animaciones activas.
                cancelAnimationFrame(activeRAFAnimations.get(el));
                activeRAFAnimations.delete(el);
            }
            if (el.dataset.subLane) { // Si el elemento ocupaba un carril, liberarlo.
                laneOccupancy[el.dataset.subLane] = false;
            }
            el.remove(); // Remover el elemento del DOM.
        });
        // Eliminar KilleRRacing si está presente en pantalla.
        if (killeRacingInstance) {
            if (killeRacingAnimId) {
                cancelAnimationFrame(killeRacingAnimId);
                killeRacingAnimId = null;
            }
            if (killeRacingInstance.parentNode) {
                killeRacingInstance.parentNode.removeChild(killeRacingInstance);
            }
            killeRacingInstance = null;
            laneOccupancy.left = false; // Liberar ambos carriles que ocupaba KilleRRacing.
            laneOccupancy.right = false;
        }
        // Eliminar KilleRRacing en modo ataque si está presente
        if (killeRacingAttackInstance && killeRacingAttackInstance.parentNode) {
            if (killeRacingAttackAnimId) {
                cancelAnimationFrame(killeRacingAttackAnimId);
                killeRacingAttackAnimId = null;
            }
            killeRacingAttackInstance.parentNode.removeChild(killeRacingAttackInstance);
            killeRacingAttackInstance = null;
            isKillerRacingAttacking = false;
        }
    }

    /**
     * Maneja el final del turno de un jugador o el final del juego completo.
     * Esta función se llama cuando un jugador ha respondido el número máximo de sumas.
     */
    function handlePlayerTurnEnd() {
        pauseGame(); // Pausar el juego.
        setDirectionalControlsActive(false); // Desactivar todos los controles.
        setInputControlsActive(false);

        // Limpiar cualquier suma o elemento que quede en pantalla.
        clearGameElements();

        if (gameMode === 'solo') {
            endGame(); // Si es modo solitario, el juego termina.
        } else if (gameMode === 'twoPlayers') {
            if (gameRound === 0) { // Si terminó el turno del Jugador 1
                showMessage(`¡Tiempo de ${players[0].name} terminado!\nAhora es el turno de ${players[1].name}.`);
                // La transición real se hace después de que el usuario haga clic en OK.
                // La función `showMessage` ya tiene un callback para el botón OK que llama a `resumeGame`
                // Necesitamos que `transitionToNextPlayerTurn` se llame *después* de que el mensaje se cierre.
                // Esto se gestionará en el `safeReattachListener` del botón OK en `showMessage`.
                // Por ahora, solo necesitamos marcar que el turno de P1 ha terminado y P2 es el siguiente.
                // La lógica de `transitionToNextPlayerTurn` se moverá al callback del botón OK de `showMessage`.
            } else { // Si terminó el turno del Jugador 2
                endGame(); // Ambos jugadores han terminado, el juego finaliza.
            }
        }
    }

    /**
     * Maneja la transición al turno del siguiente jugador en el modo de dos jugadores.
     * Reinicia las variables de estado y la interfaz para el nuevo jugador.
     */
    function transitionToNextPlayerTurn() {
        gameRound = 1; // Cambiar al turno del Jugador 2.
        seconds = 0; // Reiniciar el temporador para el nuevo turno.

        // Reiniciar estados relacionados con efectos y aparición de objetos.
        isBarrierEffectActive = false; 
        barrierSimpleSumsCounter = 0;
        barrierTimeElapsed = false; 

        // Restablecer la lógica de fases para el nuevo turno del jugador.
        currentPhase = 'sums';
        sumsCountForCurrentPhase = Math.floor(Math.random() * (SUMS_PER_OBJECT_PHASE_MAX - SUMS_PER_OBJECT_PHASE_MIN + 1)) + SUMS_PER_OBJECT_PHASE_MIN;
        currentSumsGeneratedInPhase = 0;
        objectGeneratedThisPhase = false;
        operationsAnsweredSinceLastKilleRacing = 0; // Reiniciar contador de operaciones para KilleRRacing.
        
        // Detener y reiniciar los intervalos de generación para el nuevo turno.
        clearInterval(createSumInterval); 
        clearInterval(createTreesInterval);
        clearInterval(generateSimpleSumsInterval); 
        
        const p2 = players[1]; // Referencia al Jugador 2.
        
        if (playerCarDisplay) playerCarDisplay.src = p2.carImage; // Cambiar la imagen del coche al del Jugador 2.
        if (p2.nameDisplay) p2.nameDisplay.textContent = p2.name; // Actualizar el nombre del jugador en pantalla.

        // Restablecer la posición del coche al centro del carril para el nuevo jugador.
        if (playerCarDisplay && players[0].laneElement) {
            const laneWidth = players[0].laneElement.offsetWidth;
            const carWidth = playerCarDisplay.offsetWidth;
            const initialCarPosLeft = (laneWidth / 2) - (carWidth / 2);
            players[1].currentCarPosPx = initialCarPosLeft;
            players[1].currentCarBottomRem = MAX_CAR_VERTICAL_POS_REM;
            playerCarDisplay.style.left = initialCarPosLeft + "px";
            playerCarDisplay.style.bottom = players[1].currentCarBottomRem + "vmin";
            if (p2.nameDisplay) {
                p2.nameDisplay.style.left = (initialCarPosLeft + (carWidth / 2)) + "px";
                p2.nameDisplay.style.bottom = (players[1].currentCarBottomRem + 7) + "vmin"; 
            }
        }
        
        // Reiniciar todas las luces de feedback a amarillo.
        globalOperationsFeedbackLights.forEach(light => {
            light.classList.remove('green', 'red');
            light.classList.add('yellow');
        });
        p2.sumsAnsweredInRound = 0; // Reiniciar el contador de sumas respondidas para el nuevo jugador.
        
        // Iniciar los intervalos de generación de sumas y árboles para el nuevo turno.
        createSumInterval = setInterval(createSum, SUM_CREATION_INTERVAL);
        createTreesInterval = setInterval(createTrees, ADJUSTED_TREE_CREATION_INTERVAL); 
    }

    /**
     * Termina el juego, calcula la puntuación de pericia (para modo solo) y muestra los resultados finales.
     * Gestiona la visualización de la pantalla de resultados.
     */
    function endGame() {
        pauseGame(); // Pausar el juego.
        clearInterval(timeInterval); // Detener el temporador principal.
        timeInterval = null;

        if (document.fullscreenElement) {
            document.exitFullscreen(); // Salir del modo pantalla completa si está activo.
        }

        clearGameElements(); // Limpiar todos los elementos del juego.

        if (gameOverlay) {
            gameOverlay.style.display = 'none'; // Ocultar la capa de superposición del juego.
        }

        gameScreen.style.display = 'none'; // Ocultar la pantalla del juego.
        resultsScreen.style.display = 'flex'; // Mostrar la pantalla de resultados.

        const resultsContent = document.getElementById('dynamic-results-content');
        resultsContent.innerHTML = ''; // Limpiar cualquier contenido previo en la pantalla de resultados.

        if (gameMode === 'solo') {
            const player = players[0];
            const totalTime = seconds;
            
            // Calcular el porcentaje de respuestas correctas
            const totalAnswers = player.correctAnswers + player.incorrectAnswers;
            const percentageCorrect = totalAnswers > 0 ? (player.correctAnswers / totalAnswers) : 1; // Evitar división por cero

            // Calcular la puntuación de pericia (más puntos en menos tiempo con alta precisión es mejor).
            // Normalizar el tiempo para que tiempos más cortos den valores más altos.
            // Si el tiempo es 0 (lo cual es raro en un juego real), evitamos la división por cero.
            const adjustedTime = Math.max(1, totalTime); // Asegura que el tiempo sea al menos 1 para la división.
            
            // Factor de ajuste para la escala de 1 a 10
            const maxPossibleScore = currentMaxAnsweredSums * 10 + (currentMaxAnsweredSums / 2) * 10; // Estimación de puntos máximos
            const maxPossibleTime = currentMaxAnsweredSums * 2; // Estimación de tiempo máximo (2s por pregunta)
            const baseProficiency = ((player.score + player.pitsPoints) / maxPossibleScore) * 100; // Puntuación base sobre 100
            const timeFactor = (maxPossibleTime - adjustedTime) / maxPossibleTime; // Factor de tiempo (más alto si el tiempo es bajo)
            const accuracyFactor = percentageCorrect; // Factor de precisión (0 a 1)

            // Combinar factores para la calificación final (0-10)
            let rawProficiency = baseProficiency * (1 + timeFactor) * accuracyFactor;
            rawProficiency = Math.max(0, Math.min(100, rawProficiency)); // Limitar a 0-100

            // Escalar a 1-10 y mostrar con un decimal si es necesario
            let proficiencyRating = (rawProficiency / 10).toFixed(1); // Muestra un decimal
            if (proficiencyRating > 10) proficiencyRating = 10; // Limitar a 10
            if (proficiencyRating < 1) proficiencyRating = 1; // Limitar a 1


            let displayedTime = `${Math.floor(seconds / 60).toString().padStart(2, '0')}:${(seconds % 60).toString().padStart(2, '0')}`;
            
            // Construir el panel de resultados para un solo jugador.
            const soloResultPanel = document.createElement('div');
            soloResultPanel.classList.add('solo-result-panel');
            soloResultPanel.innerHTML = `
                <img src="https://i.postimg.cc/gJ3B0X2t/IMG-Carabela-1.png" alt="Carabela" class="pulsating-image-glow" />
                <div class="results-line"></div>
                <h2 class="game-title-text">${player.name}</h2>
                <div class="results-name-line"></div>
                
                <h3 class="proficiency-score-display">Calificación: ${proficiencyRating}</h3>
                <div class="results-stats-column">
                    <div class="results-stat-row"><span class="results-stats-label">Puntos:</span> <span class="results-stats-value">${player.score.toString().padStart(3, '0')}</span></div>
                    <div class="results-stat-row"><span class="results-stats-label">Pits:</span> <span class="results-stats-value">${player.pitsPoints}</span></div>
                    <div class="results-stat-row"><span class="results-stats-label">Tiempo:</span> <span class="results-stats-value">${displayedTime}</span></div>
                    <div class="results-stat-row"><span class="results-stats-label">Correctas:</span> <span class="results-stats-value">${player.correctAnswers}</span></div>
                    <div class="results-stat-row"><span class="results-stats-label">Incorrectas:</span> <span class="results-stats-value">${player.incorrectAnswers}</span></div>
                </div>

                <div class="results-reset-line"></div>
                <div class="results-return-button results-btn" onclick="resetToModeSelectionScreen()">
                    <img src="https://i.postimg.cc/zX7R5whP/Bt-Reset.png" alt="Volver al Inicio" />
                </div>
            `;
            resultsContent.appendChild(soloResultPanel);

        } else { // Modo de dos jugadores.
            const player1 = players[0];
            const player2 = players[1];

            let winner = null;
            let loser = null;
            let tie = false;

            // Determinar el ganador basado en la puntuación.
            if (player1.score > player2.score) {
                winner = player1;
                loser = player2;
            } else if (player2.score > player1.score) {
                winner = player2;
                loser = player1; 
            } else {
                tie = true; // Empate.
                winner = player1; 
                loser = player2; 
            }

            // Función para determinar el tipo de trofeo (oro para ganador, plata para perdedor/empate).
            const getTrophyInfo = (playerData, isTie) => {
                if (isTie) return { type: 'silver', imgSrc: "https://i.postimg.cc/Y23TbM85/Trofeo-Plata.png" };
                return playerData === winner ? 
                       { type: 'gold', imgSrc: "https://i.postimg.cc/90WKCnXg/Trofeo-Oro.png" } :
                       { type: 'silver', imgSrc: "https://i.postimg.cc/Y23TbM85/Trofeo-Plata.png" };
            };

            const player1Trophy = getTrophyInfo(player1, tie);
            const player2Trophy = getTrophyInfo(player2, tie);

            // Construir la tabla de resultados para dos jugadores.
            const resultsTable = document.createElement('table');
            resultsTable.classList.add('results-table');
            
            resultsTable.innerHTML = `
                <thead>
                    <tr>
                        <th>Jugador</th>
                        <th>Puntuación</th>
                        <th>Desempeño</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="player-name-cell">
                            <h3>${player1.name}</h3>
                            <img src="${player1.carabelaImage}" class="results-car-image pulsating-image-glow" alt="Carabela ${player1.name}" />
                        </td>
                        <td class="player-score-cell">
                            <div class="results-stat-row"><span class="results-stats-label">Puntos:</span> <span class="results-stats-value">${player1.score.toString().padStart(3, '0')}</span></div>
                            <div class="results-stat-row"><span class="results-stats-label">Pits:</span> <span class="results-stats-value">${player1.pitsPoints}</span></div>
                            <img src="${player1Trophy.imgSrc}" class="results-trophy-image ${player1Trophy.type}-trophy-image" alt="Trofeo ${player1Trophy.type}" />
                        </td>
                        <td class="player-performance-cell">
                            <div class="results-stat-row"><span class="results-stats-label">Correctas:</span> <span class="results-stats-value">${player1.correctAnswers}</span></div>
                            <div class="results-stat-row"><span class="results-stats-label">Incorrectas:</span> <span class="results-stats-value">${player1.incorrectAnswers}</span></div>
                        </td>
                    </tr>
                    <tr>
                        <td class="player-name-cell">
                            <h3>${player2.name}</h3>
                            <img src="${player2.carabelaImage}" class="results-car-image pulsating-image-glow" alt="Carabela ${player2.name}" />
                        </td>
                        <td class="player-score-cell">
                            <div class="results-stat-row"><span class="results-stats-label">Puntos:</span> <span class="results-stats-value">${player2.score.toString().padStart(3, '0')}</span></div>
                            <div class="results-stat-row"><span class="results-stats-label">Pits:</span> <span class="results-stats-value">${player2.pitsPoints}</span></div>
                            <img src="${player2Trophy.imgSrc}" class="results-trophy-image ${player2Trophy.type}-trophy-image" alt="Trofeo ${player2Trophy.type}" />
                        </td>
                        <td class="player-performance-cell">
                            <div class="results-stat-row"><span class="results-stats-label">Correctas:</span> <span class="results-stats-value">${player2.correctAnswers}</span></div>
                            <div class="results-stat-row"><span class="results-stats-label">Incorrectas:</span> <span class="results-stats-value">${player2.incorrectAnswers}</span></div>
                        </td>
                    </tr>
                </tbody>
            `;
            resultsContent.appendChild(resultsTable);

            // Título de resultados finales para modo de dos jugadores
            const finalResultsTitle = document.createElement('h3');
            finalResultsTitle.classList.add('proficiency-score-display');
            finalResultsTitle.textContent = '¡Resultados Finales!';
            resultsContent.appendChild(finalResultsTitle);

            const resetButtonLine = document.createElement('div');
            resetButtonLine.classList.add('results-reset-line');
            resultsContent.appendChild(resetButtonLine);

            const resetButton = document.createElement('div');
            resetButton.classList.add('results-return-button', 'results-btn'); 
            resetButton.onclick = resetToModeSelectionScreen;
            resetButton.innerHTML = `
                <img src="https://i.postimg.cc/zX7R5whP/Bt-Reset.png" alt="Volver al Inicio" />
            `;
            resultsContent.appendChild(resetButton);
        }
    }

    /**
     * Muestra una caja de mensaje personalizada en el centro de la pantalla, superponiendo el juego.
     * Se utiliza para mensajes importantes del juego (ej. inicio de turno, fin de juego).
     * @param {string} message - El texto del mensaje a mostrar. Puede contener saltos de línea `\n`.
     */
    function showMessage(message) {
        if (gameOverlay) {
            gameOverlay.style.display = 'block'; // Mostrar la capa de superposición.
        }
        pauseGame(); // Pausar el juego automáticamente al mostrar un mensaje.
        setDirectionalControlsActive(false); // Desactivar controles de movimiento.
        setInputControlsActive(false); // Desactivar controles de respuesta.

        const messageBox = document.createElement('div');
        messageBox.style.cssText = `
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.9); color: white; padding: 30px; border-radius: 15px;
            z-index: 1000; text-align: center; white-space: pre-line; border: 2px solid yellow;
            box-shadow: 0 0 20px rgba(255, 255, 0, 0.9);
        `;
        
        // Reemplazar "¡CAMPEÓN! 👑" con un estilo animado.
        let htmlContent = message.split('\n').map(line => {
            if (line.includes('¡CAMPEÓN! 👑')) {
                return line.replace('¡CAMPEÓN! 👑', '<span class="campeon-text">¡CAMPEÓN! 👑</span>');
            }
            return line;
        }).join('<br>');

        messageBox.innerHTML = htmlContent;

        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'OK';
        closeBtn.style.cssText = `
            margin-top: 25px; padding: 12px 25px; background-color: yellow; color: black;
            border: none; border-radius: 8px; cursor: pointer; font-size: 1.1rem; font-weight: bold;
        `;
        messageBox.appendChild(closeBtn);

        let messageBoxOpen = true;
        // Oyente de teclado para cerrar el mensaje con la tecla Enter.
        const messageKeyListener = (e) => {
            if (messageBoxOpen && e.key === 'Enter') {
                e.preventDefault();
                e.stopPropagation();
                messageBoxOpen = false; 
                closeBtn.click(); // Simular clic en el botón OK.
                document.removeEventListener('keydown', messageKeyListener); 
            }
        };
        document.addEventListener('keydown', messageKeyListener);
        
        // Adjuntar oyente al botón OK para cerrar el mensaje y reanudar el juego (o reiniciar).
        safeReattachListener(closeBtn, 'click', () => {
            if (messageBox.parentNode === document.body) {
                document.body.removeChild(messageBox); 
            }
            if (gameOverlay) {
                gameOverlay.style.display = 'none'; 
            }

            // Si el mensaje es de derrota por KilleRRacing, reiniciar el juego completo.
            if (message.includes("KilleRRacing") && message.includes("¡Has Muerto!")) { 
                resetToModeSelectionScreen();
                return;
            }
            
            // NUEVA LÓGICA: Diferenciar entre el mensaje inicial de bienvenida y los mensajes de fin de turno.
            const isInitialPlayer1Message = message.includes(`¡Hola ${players[0].name}!\nPrepárate...`);

            if (gameMode === 'twoPlayers') {
                if (isInitialPlayer1Message) {
                    // Si es el mensaje inicial del Jugador 1, simplemente reanudar el juego para él.
                    setTimeout(() => {
                        resumeGame(); 
                        setDirectionalControlsActive(true); 
                        setInputControlsActive(false);
                    }, 1000); 
                } else if (message.includes(`¡Tiempo de ${players[0].name} terminado!`)) {
                    // Si es el mensaje de fin de turno del Jugador 1, transicionar al Jugador 2 y mostrar su mensaje.
                    transitionToNextPlayerTurn();
                    showMessage(`¡Turno de ${players[1].name}!\nPrepárate...`); // Mostrar mensaje de transición para el Jugador 2.
                } else {
                    // Si es el mensaje de "Prepárate" del Jugador 2, simplemente reanudar el juego para él.
                    setTimeout(() => {
                        resumeGame(); 
                        setDirectionalControlsActive(true); 
                        setInputControlsActive(false);
                    }, 1000); 
                }
            } else { // Modo solitario
                // Retraso antes de reanudar el juego para una transición suave.
                setTimeout(() => {
                    resumeGame(); 
                    setDirectionalControlsActive(true); 
                    setInputControlsActive(false);
                }, 1000); 
            }
        });

        document.body.appendChild(messageBox); // Añadir la caja de mensaje al cuerpo del documento.
    }

    /**
     * Selecciona el modo de juego (solitario o en pareja) y guarda la elección.
     * Luego, avanza a la pantalla de selección de nivel.
     * @param {string} mode - El modo de juego seleccionado ('solo' o 'twoPlayers').
     */
    function selectMode(mode) {
        gameMode = mode;
        localStorage.setItem('gameMode', mode); 
        modeSelectionScreen.style.display = 'none'; 
        levelSelectionScreen.style.display = 'flex'; 
        currentLevel = 'principiante'; // Nivel por defecto al seleccionar modo.
        console.log("Modo seleccionado:", mode);
    }

    /**
     * Selecciona el nivel de juego y ajusta las propiedades del juego (cantidad de sumas, intervalos de creación)
     * en consecuencia. Luego, avanza a la pantalla de entrada de nombre.
     * @param {string} level - El nivel de juego seleccionado ('principiante', 'novato', 'experto').
     */
    function selectLevel(level) {
        currentLevel = level;
        localStorage.setItem('selectedLevel', level); 
        levelSelectionScreen.style.display = 'none'; 

        // Configurar el número máximo de sumas a responder y el intervalo de creación de sumas según el nivel.
        switch(currentLevel) {
            case 'principiante':
                currentMaxAnsweredSums = 10;
                SUM_CREATION_INTERVAL = 1800; 
                // Cooldowns para Principiante
                INITIAL_PIT_COOLDOWN = 15000;
                INITIAL_HOLE_COOLDOWN = 10000;
                INITIAL_BARRIER_COOLDOWN = 20000;
                break;
            case 'novato':
                currentMaxAnsweredSums = 5; // 5 operaciones por fase
                SUM_CREATION_INTERVAL = 2000;
                // Reducir cooldowns para Novato
                INITIAL_PIT_COOLDOWN = 10000; // 10 segundos
                INITIAL_HOLE_COOLDOWN = 7000;  // 7 segundos
                INITIAL_BARRIER_COOLDOWN = 15000; // 15 segundos (Barreras menos frecuentes)
                break;
            case 'experto':
                currentMaxAnsweredSums = 5; // 5 operaciones por fase
                SUM_CREATION_INTERVAL = 1800;
                // Reducir cooldowns aún más para Experto
                INITIAL_PIT_COOLDOWN = 7000;  // 7 segundos
                INITIAL_HOLE_COOLDOWN = 5000;  // 5 segundos
                INITIAL_BARRIER_COOLDOWN = 10000; // 10 segundos
                break;
            default: 
                currentMaxAnsweredSums = 10;
                SUM_CREATION_INTERVAL = 1800;
                INITIAL_PIT_COOLDOWN = 15000;
                INITIAL_HOLE_COOLDOWN = 10000;
                INITIAL_BARRIER_COOLDOWN = 20000;
        }
        
        // Mostrar la pantalla de entrada de nombre correspondiente al modo de juego.
        if (gameMode === 'solo') {
            startScreenSolo.style.display = 'flex';
            const playerNameInput = document.getElementById("player-name");
            if (playerNameInput) {
                playerNameInput.focus(); // Poner el foco en el campo de nombre.
                playerNameInput.value = ''; // Limpiar el campo de nombre
            }
        } else if (gameMode === 'twoPlayers') {
            startScreenTwoPlayers.style.display = 'flex';
            const player1NameInput = document.getElementById("player1-name-input");
            const player2NameInput = document.getElementById("player2-name-input");
            if (player1NameInput) {
                player1NameInput.focus(); // Poner el foco en el campo de nombre del Jugador 1.
                player1NameInput.value = ''; // Limpiar el campo de nombre
            }
            if (player2NameInput) {
                player2NameInput.value = ''; // Limpiar el campo de nombre
            }
        }
        console.log("Nivel seleccionado:", level);
    }

    /**
     * Inicia el juego de matemáticas en modo solitario después de que el jugador ingresa su nombre.
     * Oculta la pantalla de entrada de nombre y muestra la pantalla del juego.
     */
    function startGame() {
        const playerNameInput = document.getElementById("player-name");
        if (!playerNameInput) {
            console.error("Error: Campo de nombre de jugador no encontrado.");
            showMessage("Error interno: Campo de nombre de jugador no encontrado.");
            return;
        }
        const name = playerNameInput.value;
        if (!name.trim()) {
            showMessage("Por favor, ingrese su nombre.");
            return;
        }

        players[0].name = name; // Asignar el nombre al Jugador 1.
        localStorage.setItem('playerName1', name); // Guardar el nombre en el almacenamiento local.
        
        if (startScreenSolo && gameScreen) {
            startScreenSolo.style.display = "none";
            gameScreen.style.display = "flex"; 
            initMathGame(); // Inicializar el juego de matemáticas.
            console.log("Juego individual iniciado para:", name);
        } else {
            console.error("Error: Pantallas de juego no encontradas para inicio.");
            showMessage("Error interno: Pantallas de juego no encontradas.");
        }
    }

    /**
     * Inicia el juego de dos jugadores después de que ambos jugadores ingresan sus nombres.
     * Oculta la pantalla de entrada de nombres y muestra la pantalla del juego.
     */
    function startGameTwoPlayers() {
        const player1NameInput = document.getElementById("player1-name-input");
        const player2NameInput = document.getElementById("player2-name-input");

        if (!player1NameInput || !player2NameInput) {
            console.error("Error: Campos de entrada de nombre de jugador no encontrados.");
            showMessage("Error interno: Campos de entrada de nombre de jugador no encontrados.");
            return;
        }

        const name1 = player1NameInput.value;
        const name2 = player2NameInput.value;

        if (!name1.trim() || !name2.trim()) {
            showMessage("Por favor, ingrese los nombres de ambos jugadores.");
            return;
        }

        players[0].name = name1; // Asignar nombre al Jugador 1.
        players[1].name = name2; // Asignar nombre al Jugador 2.
        localStorage.setItem('playerName1', name1); 
        localStorage.setItem('playerName2', name2); 

        if (startScreenTwoPlayers && gameScreen) {
            startScreenTwoPlayers.style.display = "none";
            gameScreen.style.display = "flex"; 
            initMathGame(); // Inicializar el juego de matemáticas.
            console.log("Juego de dos jugadores iniciado con:", name1, "y", name2);
        } else {
            console.error("Error: Pantallas de juego no encontradas para inicio de dos jugadores.");
            showMessage("Error interno: Pantallas de juego no encontradas.");
        }
    }

    /**
     * Elimina y vuelve a adjuntar de forma segura un oyente de eventos a un elemento DOM.
     * Esto previene la duplicación de oyentes al re-renderizar o re-inicializar componentes,
     * asegurando que solo haya un manejador activo para un evento y elemento dados.
     * @param {HTMLElement} element - El elemento DOM al que se adjuntará el oyente.
     * @param {string} event - El tipo de evento (ej. 'click', 'keydown').
     * @param {Function} handler - La función del manejador de eventos a adjuntar.
     * @param {Object} [options] - Opciones para el oyente de eventos (ej. `{ passive: false }`).
     */
    function safeReattachListener(element, event, handler, options = {}) {
        if (element) {
            // Utilizar un mapa interno para almacenar y gestionar los oyentes adjuntos.
            const existingHandlers = element._eventHandlers || new Map();
            element._eventHandlers = existingHandlers;

            const oldHandler = existingHandlers.get(event);
            if (oldHandler) {
                element.removeEventListener(event, oldHandler, options); // Remover el oyente antiguo si existe.
            }
            element.addEventListener(event, handler, options); // Adjuntar el nuevo oyente.
            existingHandlers.set(event, handler); // Guardar el nuevo oyente en el mapa.
        }
    }

    /**
     * Reinicia completamente el juego a la pantalla de selección de modo, recargando la página.
     * Esto limpia todo el estado del juego y el almacenamiento local.
     */
    function resetToModeSelectionScreen() {
        console.log("Reiniciando a la pantalla de selección de modo...");
        if (document.fullscreenElement) {
            document.exitFullscreen(); // Salir del modo pantalla completa si está activo.
        }

        // Limpiar las configuraciones del juego guardadas en el almacenamiento local.
        localStorage.removeItem('selectedLevel');
        localStorage.removeItem('playerName1');
        localStorage.removeItem('playerName2');
        localStorage.removeItem('gameMode');

        location.reload(); // Recargar la página para reiniciar completamente el juego.
    }

    /**
     * Bucle principal del juego, impulsado por `requestAnimationFrame`.
     * Se encarga de la lógica de movimiento del coche del jugador y la detección de colisiones.
     */
    function gameLoop() {
        if (gamePaused) {
            gameLoopId = null; // Si el juego está pausado, detener el bucle.
            return;
        }

        const activePlayerIndex = gameRound; // Obtener el índice del jugador activo.

        // Mover el coche del jugador si se presionan las teclas o botones de dirección y los controles están activos.
        if (!unifiedControlsRow || !unifiedControlsRow.classList.contains('inactive-controls')) {
            if (activeKeys.ArrowLeft || activeButtons.left) { 
                moveCar('left', activePlayerIndex);
            } else if (activeKeys.ArrowRight || activeButtons.right) { 
                moveCar('right', activePlayerIndex);
            }

            if (activeKeys.ArrowUp || activeButtons.up) {
                accelerate(); // Acelerar el juego.
            } else if (activeKeys.ArrowDown || activeButtons.down) { 
                decelerate(); // Desacelerar el juego.
            }
        }

        checkCollisions(); // Verificar colisiones con los elementos del juego.

        gameLoopId = requestAnimationFrame(gameLoop); // Solicitar el próximo frame para continuar el bucle.
    }

    /**
     * Inicia el ataque de KilleRRacing sobre la operación actual.
     * @param {HTMLElement} sumElement - El elemento DOM de la suma que está siendo atacada.
     */
    function startKillerRacingAttack(sumElement) {
        if (isKillerRacingAttacking) return; // Ya hay un ataque en curso

        isKillerRacingAttacking = true;
        pauseGame(); // Pausa el movimiento general del juego
        setDirectionalControlsActive(false); // Desactiva los controles de dirección
        setInputControlsActive(true); // Activa la caja de respuesta

        // Posicionar la suma en el centro inferior para el ataque
        const playerLane = document.getElementById('player1-lane');
        const laneWidth = playerLane.offsetWidth;
        const sumWidth = sumElement.offsetWidth;
        const sumHeight = sumElement.offsetHeight;
        
        // Reposicionar la suma al final de la línea segmentada (parte inferior de player1-lane)
        sumElement.style.position = 'absolute';
        sumElement.style.left = `${(laneWidth / 2) - (sumWidth / 2)}px`;
        sumElement.style.top = `${playerLane.offsetHeight - sumHeight - 10}px`; // 10px de margen sobre el final del carril
        sumElement.classList.add('colliding-highlight'); // Resaltar la suma

        // Crear o reutilizar la instancia de KilleRRacing para el ataque
        if (!killeRacingAttackInstance) {
            killeRacingAttackInstance = document.createElement('img');
            killeRacingAttackInstance.src = 'https://i.postimg.cc/gcNB342d/Carabela.png'; // 
            killeRacingAttackInstance.classList.add('kille-racing', 'attack-mode');
            // Asegurarse de que gameAreaContainer está definido y es un elemento DOM válido
            if (gameAreaContainer) {
                gameAreaContainer.appendChild(killeRacingAttackInstance);
            } else {
                console.error("Error: gameAreaContainer no está definido. No se puede añadir killeRacingAttackInstance.");
                return;
            }
        }
        killeRacingAttackInstance.style.display = 'block';
        killeRacingAttackInstance.style.top = `${KILLER_RACING_ATTACK_START_Y}vmin`; // Posición inicial arriba
        killeRacingAttackInstance.style.left = '50%';
        killeRacingAttackInstance.style.transform = 'translateX(-50%)';
        
        // Calcular la duración del ataque basada en el tiempo de la primera respuesta
        let attackDurationMs;
        if (gameMode === 'solo') {
            attackDurationMs = players[gameRound].firstResponseTime;
        } else { // twoPlayers
            const p1Time = players[0].firstResponseTime || 0; // Usar 0 si no ha respondido aún
            const p2Time = players[1].firstResponseTime || 0;
            const slowestFirstResponseTime = Math.max(p1Time, p2Time);
            // Sumar un valor aleatorio entre 1 y 2 segundos (1000ms a 2000ms)
            const generousAddition = TWO_PLAYER_GENEROUS_TIME_ADDITION_MS + Math.random() * TWO_PLAYER_GENEROUS_TIME_ADDITION_MS;
            attackDurationMs = slowestFirstResponseTime + generousAddition;
        }

        // Asegurar una duración mínima para evitar velocidades extremas si el tiempo de respuesta es muy bajo.
        attackDurationMs = Math.max(500, attackDurationMs); // Mínimo 0.5 segundos

        // Calcular la velocidad de KilleRRacing para que llegue a la suma en la duración calculada.
        // Convertir vmin a píxeles para un cálculo más preciso si es necesario, o mantener en vmin.
        // Para simplificar, asumiremos que la velocidad en vmin/frame es suficiente.
        const targetTopVmin = (sumElement.getBoundingClientRect().top / window.innerHeight) * 100 - (killeRacingAttackInstance.offsetHeight / window.innerHeight) * 100;
        const distanceVmin = targetTopVmin - KILLER_RACING_ATTACK_START_Y;
        const framesToReach = attackDurationMs / (1000 / 60); // Convertir ms a frames (asumiendo 60fps)
        killerRacingCurrentSpeed = distanceVmin / framesToReach;

        killeRacingAttackStartTime = Date.now(); // Registrar el inicio del ataque.

        // Limpiar la caja de respuesta y enfocarla
        if (commonControls.answerBox) {
            commonControls.answerBox.value = '';
            commonControls.answerBox.focus();
        }

        // Iniciar la animación
        killeRacingAttackAnimId = requestAnimationFrame(() => animateKillerRacingAttack(sumElement));
        console.log(`DEBUG: KilleRRacing ha iniciado su ataque sobre la operación. Duración esperada: ${attackDurationMs.toFixed(0)}ms`);
    }

    /**
     * Anima el descenso de KilleRRacing en modo ataque sobre la operación.
     * @param {HTMLElement} sumElement - El elemento DOM de la suma que está siendo atacada.
     */
    function animateKillerRacingAttack(sumElement) {
        if (!isKillerRacingAttacking || !killeRacingAttackInstance || !sumElement) {
            killeRacingAttackAnimId = null;
            return;
        }

        let currentTopVmin = parseFloat(killeRacingAttackInstance.style.top);
        currentTopVmin += killerRacingCurrentSpeed; // Mover hacia abajo usando la velocidad calculada.
        killeRacingAttackInstance.style.top = `${currentTopVmin}vmin`;

        const elapsedTime = Date.now() - killeRacingAttackStartTime;
        const targetTopVmin = (sumElement.getBoundingClientRect().top / window.innerHeight) * 100 - (killeRacingAttackInstance.offsetHeight / window.innerHeight) * 100;

        // Comprobar si KilleRRacing ha "chocado" con la suma (su parte inferior sobrepasa la parte superior de la suma)
        // O si el tiempo de ataque ha transcurrido.
        if (currentTopVmin >= targetTopVmin || elapsedTime >= (players[gameRound].firstResponseTime + (gameMode === 'twoPlayers' ? TWO_PLAYER_GENEROUS_TIME_ADDITION_MS : 0))) {
            endKillerRacingAttack(sumElement, false); // La suma no fue respondida a tiempo.
            console.log("DEBUG: KilleRRacing ha alcanzado la operación sin respuesta o el tiempo ha expirado.");
        } else {
            killeRacingAttackAnimId = requestAnimationFrame(() => animateKillerRacingAttack(sumElement));
        }
    }

    /**
     * Finaliza el ataque de KilleRRacing sobre la operación.
     * @param {HTMLElement} sumElement - El elemento DOM de la suma que estaba siendo atacada.
     * @param {boolean} wasAnsweredCorrectly - True si la suma fue respondida correctamente, false si no.
     */
    function endKillerRacingAttack(sumElement, wasAnsweredCorrectly) {
        if (!isKillerRacingAttacking) return;

        cancelAnimationFrame(killeRacingAttackAnimId);
        killeRacingAttackAnimId = null;
        isKillerRacingAttacking = false;

        sumElement.classList.remove('colliding-highlight');
        if (killeRacingAttackInstance && killeRacingAttackInstance.parentNode) {
            killeRacingAttackInstance.style.display = 'none'; // Ocultar KilleRRacing de ataque
        }

        if (!wasAnsweredCorrectly) {
            // Lógica de penalización si no se respondió a tiempo
            console.log("¡Tiempo agotado! KilleRRacing te atrapó. Fin del juego/turno.");
            showMessage(`
                <img src="https://i.postimg.cc/SNCjdmF9/Math-Killer.png" alt="KilleRRacing" style="max-width: 100px; margin-bottom: 10px; filter: drop-shadow(0 0 8px yellow) drop-shadow(0 0 15px yellow);" />
                <br>KilleRRacing
                <br>¡Has Muerto!
                <br><span class='blinking-text'>JA, JA, JA, JA.</span>
            `);
            // La función showMessage ya maneja el reinicio del juego.
        } else {
            // Si fue respondida correctamente, simplemente reanudar el juego normal
            resumeGame(); // Reanudar el movimiento normal del juego
            setDirectionalControlsActive(true); // Reactivar controles de dirección
            setInputControlsActive(false); // Desactivar la entrada de respuesta
        }
        // Remover la suma del DOM después de la interacción
        if (sumElement && sumElement.parentNode) {
            sumElement.parentNode.removeChild(sumElement);
            activeRAFAnimations.delete(sumElement);
        }
        currentCollidingSum = null; // Limpiar la referencia
    }

    /**
     * Calcula dinámicamente las velocidades de movimiento de los elementos del juego y sus posiciones iniciales
     * basándose en las dimensiones actuales de la pantalla (responsividad).
     * También ajusta las frecuencias de aparición de sumas y árboles.
     */
    function calculateDynamicSpeedsAndPositions() {
        let currentRoadMainElement = document.getElementById('player1-lane');
        
        if (!currentRoadMainElement) {
            console.warn("calculateDynamicSpeedsAndPositions: El elemento 'player1-lane' no se encontró. No se pueden calcular las velocidades dinámicas.");
            return;
        }

        roadMain = currentRoadMainElement;

        const currentRoadWidth = roadMain.offsetWidth; 
        const currentRoadHeight = roadMain.offsetHeight;

        // Calcular factores de escala basados en el tamaño de la pista de juego.
        const scaleX = currentRoadWidth / BASE_ROAD_WIDTH;
        const scaleY = currentRoadHeight / BASE_ROAD_HEIGHT;

        // Ajustar velocidades de movimiento horizontal y vertical según la escala.
        ADJUSTED_CAR_MOVEMENT_SPEED = INITIAL_CAR_MOVEMENT_SPEED_BASE * scaleX;
        ADJUSTED_SUM_HORIZONTAL_SPEED = INITIAL_SUM_HORIZONTAL_SPEED_BASE * scaleX;

        let levelSumSpeedBase = 1;
        let levelSumCreationIntervalBase = 3500;
        let levelSumSpeedIncreaseValue = 0.1;

        // Ajustar la velocidad de caída de las sumas y la frecuencia de creación según el nivel de dificultad.
        switch(currentLevel) {
            case 'principiante':
                levelSumSpeedBase = 3;
                levelSumCreationIntervalBase = 1800; 
                levelSumSpeedIncreaseValue = 0.15;
                break;
            case 'novato':
                levelSumSpeedBase = 4.5;
                levelSumCreationIntervalBase = 2000;
                levelSumSpeedIncreaseValue = 0.2;
                break;
            case 'experto':
                levelSumSpeedBase = 5.5; 
                levelSumCreationIntervalBase = 1800;
                levelSumSpeedIncreaseValue = 0.25;
                break;
        }

        ADJUSTED_INITIAL_SUM_FALL_SPEED = levelSumSpeedBase * scaleY;
        ADJUSTED_SUM_SPEED_INCREASE_VALUE = levelSumSpeedIncreaseValue * scaleY; 
        ADJUSTED_FALLING_OBJECT_SPEED = INITIAL_FALLING_OBJECT_SPEED_BASE * scaleY;

        SUM_CREATION_INTERVAL = Math.max(levelSumCreationIntervalBase / scaleY, 300); 
        ADJUSTED_TREE_CREATION_INTERVAL = Math.max(INITIAL_TREE_CREATION_INTERVAL_BASE / scaleY, 200); 
        
        // Asignar la velocidad inicial de caída de sumas a cada jugador.
        players.forEach(player => {
            player.currentSumSpeed = ADJUSTED_INITIAL_SUM_FALL_SPEED;
        });

        // Actualizar la imagen del coche en la pista según el jugador actual.
        if (playerCarDisplay) {
            playerCarDisplay.src = players[gameRound].carImage;
        }

        // Reposicionar el coche del jugador al centro de la pista y ajustar la posición del nombre.
        if (playerCarDisplay && currentRoadMainElement) {
            const laneWidth = currentRoadMainElement.offsetWidth;
            const carWidth = playerCarDisplay.offsetWidth;
            const initialCarPosLeft = (laneWidth / 2) - (carWidth / 2);
            players[0].car.style.left = initialCarPosLeft + "px";
            players[0].currentCarPosPx = initialCarPosLeft;
            players[0].currentCarBottomRem = MAX_CAR_VERTICAL_POS_REM;
            players[0].car.style.bottom = players[0].currentCarBottomRem + "vmin";

            if (players[0].nameDisplay) {
                players[0].nameDisplay.style.left = (players[0].currentCarPosPx + (carWidth / 2)) + "px";
                players[0].nameDisplay.style.bottom = (players[0].currentCarBottomRem + 7) + "vmin"; 
            }
        }
        
        // Limpiar todos los intervalos de creación existentes antes de re-establecerlos para evitar duplicaciones.
        clearInterval(createSumInterval); 
        clearInterval(createTreesInterval);
        clearInterval(generateSimpleSumsInterval);

        // Siempre re-establecer el intervalo de creación de árboles.
        createTreesInterval = setInterval(createTrees, ADJUSTED_TREE_CREATION_INTERVAL);
        
        // Establecer la generación de sumas/objetos según la fase actual y el estado del efecto de barrera.
        if (isBarrierEffectActive) {
            generateSimpleSumsInterval = setInterval(() => {
                createSum(); 
            }, 400);
        } else if (currentPhase === 'sums') {
            // Lógica para el boost inicial de generación de sumas
            if (players[gameRound].sumsAnsweredInRound < INITIAL_SUM_GENERATION_BOOST_COUNT) {
                createSumInterval = setInterval(createSum, INITIAL_SUM_GENERATION_BOOST_INTERVAL);
            } else {
                createSumInterval = setInterval(createSum, SUM_CREATION_INTERVAL);
            }
        }
        // Si currentPhase es 'objects', `updateTime` se encarga de llamar a `trySpawnSpecialObject`, no se necesita un intervalo aquí.

        console.log("Velocidades y posiciones dinámicas calculadas y aplicadas. Intervals re-establecidos según fase.");
    }

    /**
     * Inicializa el juego de matemáticas: configura la interfaz de usuario, adjunta oyentes de eventos,
     * restablece el estado del juego y prepara los elementos para la primera ronda.
     */
    function initMathGame() {
        console.log("Iniciando juego de matemáticas...");
        gamePaused = true; // El juego comienza pausado hasta que se muestra el mensaje de inicio.

        // Asignar referencias a los elementos DOM globales.
        bottomTrackLine = document.getElementById("bottom-track-line");
        globalOperationsFeedbackLightsContainer = document.getElementById("global-operations-feedback-lights-container");
        operationsLightbulbsRow = document.getElementById("operations-lightbulbs");
        globalScoreDisplay = document.getElementById("global-puntuacion");
        globalPitsPointsDisplay = document.getElementById("global-puntos-pits"); // Ahora mostrará pitsAvailable
        globalTimeDisplay = document.getElementById("global-tiempo");
        gameControlsArea = document.getElementById("game-controls-area");
        gameOverlay = document.getElementById("game-overlay");
        gameAreaContainer = document.getElementById("game-area-container"); 
        playerCarDisplay = document.getElementById("player-car-display"); // Obtener la referencia al elemento <img> del coche.

        playerInputStrip = document.getElementById('player-input-strip');
        unifiedControlsRow = document.getElementById('unified-controls-row');

        // Asignar referencias a los elementos DOM específicos del jugador actual.
        players[0].car = playerCarDisplay; // Ahora apunta al elemento <img>
        players[0].nameDisplay = document.getElementById("player-name-display");
        players[0].laneElement = document.getElementById('player1-lane');

        // Para el modo de dos jugadores, ambos jugadores comparten el mismo carril y coche DOM,
        // pero sus propiedades lógicas (puntuación, nombre, etc.) se gestionan por separado.
        players[1].car = playerCarDisplay; 
        players[1].nameDisplay = document.getElementById("player-name-display"); 
        players[1].laneElement = document.getElementById('player1-lane'); 

        // Mostrar el nombre del jugador actual en la pantalla.
        if (players[gameRound].nameDisplay) {
            players[gameRound].nameDisplay.textContent = players[gameRound].name;
        }
        // Actualizar la imagen del coche del jugador actual en la pista.
        if (playerCarDisplay) {
            playerCarDisplay.src = players[gameRound].carImage;
        }

        // Asignar referencias a los controles comunes (caja de respuesta, botones).
        commonControls.answerBox = document.getElementById("caja-respuesta-player1");
        commonControls.enterButton = document.getElementById("boton-enter-player1");
        commonControls.resetButton = document.getElementById("boton-reset-player1"); 
        commonControls.upButton = document.getElementById("btn-arriba-player1"); 
        commonControls.downButton = document.getElementById("btn-abajo-player1");
        commonControls.leftButton = document.getElementById("btn-izquierda-player1");
        commonControls.rightButton = document.getElementById("btn-derecha-player1");

        // Inicializar las luces de feedback de operaciones (semáforos).
        operationsLightbulbsRow.innerHTML = '';
        globalOperationsFeedbackLights = [];
        for (let i = 0; i < currentMaxAnsweredSums; i++) { 
            const light = document.createElement('div');
            light.classList.add('operation-light', 'yellow'); // Todas comienzan en amarillo.
            operationsLightbulbsRow.appendChild(light);
            globalOperationsFeedbackLights.push(light);
        }

        // Recuperar nombres de jugadores del almacenamiento local si existen.
        players[0].name = localStorage.getItem('playerName1') || players[0].name;
        if (gameMode === 'twoPlayers') {
            players[1].name = localStorage.getItem('playerName2') || players[1].name;
        }

        // Adjuntar oyentes de eventos a los controles de juego, asegurando que no se dupliquen.
        if (commonControls.enterButton) {
            safeReattachListener(commonControls.enterButton, 'click', () => {
                processAnswer(players[gameRound].id);
            });
        }
        if (commonControls.answerBox) {
            safeReattachListener(commonControls.answerBox, 'keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    processAnswer(players[gameRound].id);
                }
            });
        }
        
        // Oyentes para los botones de control táctiles (touchstart, touchend, mousedown, mouseup, mouseout).
        if (commonControls.leftButton) {
            safeReattachListener(commonControls.leftButton, 'touchstart', (e) => { e.preventDefault(); activeButtons.left = true; }, { passive: false });
            safeReattachListener(commonControls.leftButton, 'touchend', () => { activeButtons.left = false; });
            safeReattachListener(commonControls.leftButton, 'mousedown', () => { activeButtons.left = true; });
            safeReattachListener(commonControls.leftButton, 'mouseup', () => { activeButtons.left = false; });
            safeReattachListener(commonControls.leftButton, 'mouseout', () => { activeButtons.left = false; });
        }
        if (commonControls.rightButton) {
            safeReattachListener(commonControls.rightButton, 'touchstart', (e) => { e.preventDefault(); activeButtons.right = true; }, { passive: false });
            safeReattachListener(commonControls.rightButton, 'touchend', () => { activeButtons.right = false; });
            safeReattachListener(commonControls.rightButton, 'mousedown', () => { activeButtons.right = true; });
            safeReattachListener(commonControls.rightButton, 'mouseup', () => { activeButtons.right = false; });
            safeReattachListener(commonControls.rightButton, 'mouseout', () => { activeButtons.right = false; });
        }
        if (commonControls.upButton) {
            safeReattachListener(commonControls.upButton, 'touchstart', (e) => { e.preventDefault(); activeButtons.up = true; }, { passive: false });
            safeReattachListener(commonControls.upButton, 'touchend', () => { activeButtons.up = false; });
            safeReattachListener(commonControls.upButton, 'mousedown', () => { activeButtons.up = true; });
            safeReattachListener(commonControls.upButton, 'mouseup', () => { activeButtons.up = false; });
            safeReattachListener(commonControls.upButton, 'mouseout', () => { activeButtons.up = false; });
        }
        if (commonControls.downButton) {
            safeReattachListener(commonControls.downButton, 'touchstart', (e) => { e.preventDefault(); activeButtons.down = true; }, { passive: false });
            safeReattachListener(commonControls.downButton, 'touchend', () => { activeButtons.down = false; });
            safeReattachListener(commonControls.downButton, 'mousedown', () => { activeButtons.down = true; });
            safeReattachListener(commonControls.downButton, 'mouseup', () => { activeButtons.down = false; });
            safeReattachListener(commonControls.downButton, 'mouseout', () => { activeButtons.down = false; });
        }

        // Oyente para el botón de reinicio global.
        const resetButton = document.getElementById('boton-reset-player1');
        safeReattachListener(resetButton, 'click', () => {
            resetToModeSelectionScreen();
        });

        // Restablecer todas las variables de estado del juego a sus valores iniciales.
        seconds = 0;
        gamePaused = true;
        gameRound = 0;
        gameSpeedMultiplier = 1.0;
        isBarrierEffectActive = false;
        barrierSimpleSumsCounter = 0;
        barrierTimeElapsed = false; 
        laneOccupancy = { left: false, right: false }; // Restablecer ocupación de carriles.
        operationsAnsweredSinceLastKilleRacing = 0; // Reiniciar contador de operaciones para KilleRRacing.
        
        // Restablecer las variables del sistema de fases.
        currentPhase = 'sums';
        sumsCountForCurrentPhase = Math.floor(Math.random() * (SUMS_PER_OBJECT_PHASE_MAX - SUMS_PER_OBJECT_PHASE_MIN + 1)) + SUMS_PER_OBJECT_PHASE_MIN;
        currentSumsGeneratedInPhase = 0;
        objectGeneratedThisPhase = false;
        
        // Limpiar todos los intervalos y animaciones existentes antes de re-inicializar para un estado limpio.
        clearInterval(createSumInterval); 
        clearInterval(createTreesInterval);
        clearInterval(generateSimpleSumsInterval);
        clearInterval(timeInterval);
        timeInterval = null;
        
        lastBarrierAppearanceTime = -Infinity;
        lastHoleAppearanceTime = -Infinity;
        lastPitAppearanceTime = -Infinity;
        lastKillerRacerAppearanceTime = -Infinity; // Asegurarse de que KilleRRacing pueda aparecer por tiempo si es Principiante.
        
        activeRAFAnimations.forEach((animId) => cancelAnimationFrame(animId));
        activeRAFAnimations.clear();
        clearGameElements(); // Remover todos los elementos dinámicos de la pantalla.

        // Restablecer el estado específico de cada jugador.
        players.forEach(player => {
            player.score = 0;
            player.pitsPoints = 0;
            player.pitsAvailable = 0; // REINICIAR PITS DISPONIBLES
            player.sumsAnsweredInRound = 0;
            player.correctAnswers = 0;
            player.incorrectAnswers = 0;
            player.currentCarPosPx = 0;
            player.currentCarBottomRem = MAX_CAR_VERTICAL_POS_REM;
            player.currentSumSpeed = 0; 
            player.firstResponseTime = null; // Resetear el tiempo de la primera respuesta.
            
            if (commonControls.answerBox) commonControls.answerBox.value = '';
            if (globalScoreDisplay) globalScoreDisplay.textContent = '000';
            if (globalPitsPointsDisplay) globalPitsPointsDisplay.textContent = '000'; // Actualizar para mostrar pitsAvailable
            if (globalTimeDisplay) globalTimeDisplay.textContent = '00:00';
            
            // Reposicionar el coche y el nombre del jugador en la interfaz.
            if (player.car && player.laneElement) { 
                const laneWidth = player.laneElement.offsetWidth;
                const carWidth = player.car.offsetWidth;
                const initialCarPosLeft = (laneWidth / 2) - (carWidth / 2);
                player.car.style.left = initialCarPosLeft + "px";
                player.currentCarPosPx = initialCarPosLeft;
                player.car.style.bottom = player.currentCarBottomRem + "vmin"; 
                if (player.nameDisplay) { 
                    player.nameDisplay.style.left = (player.currentCarPosPx + (carWidth / 2)) + "px";
                    player.nameDisplay.style.bottom = (player.currentCarBottomRem + 7) + "vmin"; 
                }
            }
            // Asegurarse de que los elementos del carril y el coche sean visibles.
            if (player.laneElement) player.laneElement.style.opacity = '1'; 
            if (player.car) player.car.style.opacity = '1';
            if (player.nameDisplay) player.nameDisplay.style.opacity = '1'; 
        });
        
        // Desactivar los controles al inicio del juego hasta que se reanude.
        setDirectionalControlsActive(false); 
        setInputControlsActive(false);

        // Resetear el color de todas las luces de feedback a amarillo.
        globalOperationsFeedbackLights.forEach(light => {
            light.classList.remove('green', 'red');
            light.classList.add('yellow');
        });
        
        // Calcular las velocidades y posiciones dinámicas iniciales.
        calculateDynamicSpeedsAndPositions();
        updateCSSAnimationsSpeed();

        if (commonControls.answerBox) commonControls.answerBox.focus(); // Poner el foco en la caja de respuesta.
        
        showMessage(`¡Hola ${players[0].name}!\nPrepárate...`); // Mostrar mensaje de bienvenida/preparación.
        console.log("Juego inicializado y listo para empezar.");
    }

    /**
     * Resizes the animated canvas to fill the window width and a fixed height for the lines.
     * This function is called on initial load and whenever the window is resized.
     * @param {HTMLCanvasElement} canvasElement - The canvas element to resize.
     */
    function resizeAnimatedCanvas(canvasElement) {
        if (!canvasElement) return;
        canvasElement.width = window.innerWidth;
        canvasElement.height = numberOfStaticLines * staticLineWidth; 
    }

    /**
     * Draws the eight static horizontal lines at the bottom of the animated canvas with a glow effect.
     * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
     * @param {HTMLCanvasElement} canvasElement - The canvas element.
     */
    function drawStaticLinesOnCanvas(ctx, canvasElement) {
        if (!ctx || !canvasElement) return;
        let currentY = canvasElement.height; 

        const colors = ['red', 'red', 'blue', 'blue', 'yellow', 'yellow', 'yellow', 'yellow'];

        for (let i = 0; i < numberOfStaticLines; i++) {
            const lineY = currentY - (staticLineWidth * (i + 1));

            ctx.beginPath(); 
            ctx.moveTo(0, lineY); 
            ctx.lineTo(canvasElement.width, lineY); 
            ctx.strokeStyle = colors[i]; 
            ctx.lineWidth = staticLineWidth; 

            ctx.shadowColor = colors[i]; 
            ctx.shadowBlur = glowBlur; 
            ctx.shadowOffsetX = 0; 
            ctx.shadowOffsetY = 0;

            ctx.stroke(); 
        }

        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }

    /**
     * Draws the animated gradient white line on the animated canvas.
     * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
     * @param {HTMLCanvasElement} canvasElement - The canvas element.
     * @param {number} currentGradientX - The current X position for the gradient.
     */
    function drawAnimatedGradientLineOnCanvas(ctx, canvasElement, currentGradientX) {
        if (!ctx || !canvasElement) return;
        const animatedLineY = 0; 

        const gradient = ctx.createLinearGradient(currentGradientX, 0, currentGradientX + canvasElement.width, 0);

        gradient.addColorStop(0, 'rgba(255, 255, 255, 0)');   
        gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)'); 
        gradient.addColorStop(0.5, 'rgba(255, 255, 255, 1)');   
        gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.8)'); 
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');   

        ctx.beginPath(); 
        ctx.moveTo(0, animatedLineY); 
        ctx.lineTo(canvasElement.width, animatedLineY); 
        ctx.strokeStyle = gradient; 
        ctx.lineWidth = animatedLineHeight; 
        ctx.stroke(); 
    }

    /**
     * The main animation loop for a specific animated canvas.
     * @param {HTMLCanvasElement} canvasElement - The canvas element to animate.
     * @param {CanvasRenderingContext2D} ctx - The 2D rendering context of the canvas.
     * @param {object} animationState - An object holding the current gradientX for this canvas.
     */
    function animateSpecificCanvas(canvasElement, ctx, animationState) {
        if (!ctx || !canvasElement) return;
        ctx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        animationState.gradientX -= gradientSpeed;
        if (animationState.gradientX < -canvasElement.width) {
            animationState.gradientX = 0; 
        }

        drawStaticLinesOnCanvas(ctx, canvasElement);
        drawAnimatedGradientLineOnCanvas(ctx, canvasElement, animationState.gradientX);

        requestAnimationFrame(() => animateSpecificCanvas(canvasElement, ctx, animationState));
    }

    // State objects for each canvas's animation
    const canvasAnimationStates = {
        main: { gradientX: 0 },
        level: { gradientX: 0 },
        soloName: { gradientX: 0 },
        twoPlayers: { gradientX: 0 }
    };

    /**
     * Inicialización global de referencias DOM al cargar la página.
     * Esto asegura que los elementos HTML estén disponibles antes de que se intente manipularlos en el JavaScript.
     */
    function initGlobalDOMReferences() {
        console.log("initGlobalDOMReferences: Inicializando referencias DOM.");
        modeSelectionScreen = document.getElementById("mode-selection-screen");
        levelSelectionScreen = document.getElementById("level-selection-screen");
        startScreenSolo = document.getElementById("start-screen-for-name");
        startScreenTwoPlayers = document.getElementById("start-screen-for-two-players");
        gameScreen = document.getElementById("game-screen");
        resultsScreen = document.getElementById("results-screen");
        gameOverlay = document.getElementById("game-overlay");
        gameAreaContainer = document.getElementById("game-area-container"); 
        playerCarDisplay = document.getElementById("player-car-display"); 

        // Initialize references for each animated footer canvas
        const canvases = [
            { id: 'animatedCanvas', state: canvasAnimationStates.main },
            { id: 'animatedCanvasLevel', state: canvasAnimationStates.level },
            { id: 'animatedCanvasSoloName', state: canvasAnimationStates.soloName },
            { id: 'animatedCanvasTwoPlayers', state: canvasAnimationStates.twoPlayers }
        ];

        canvases.forEach(canvasInfo => {
            const canvasElement = document.getElementById(canvasInfo.id);
            if (canvasElement) {
                const ctx = canvasElement.getContext('2d');
                resizeAnimatedCanvas(canvasElement); 
                animateSpecificCanvas(canvasElement, ctx, canvasInfo.state); 
            } else {
                console.error(`initGlobalDOMReferences: No se pudo encontrar '${canvasInfo.id}'.`);
            }
        });

        // Mostrar la pantalla de selección de modo al inicio.
        if (modeSelectionScreen) {
            modeSelectionScreen.style.display = "flex";
            console.log("initGlobalDOMReferences: 'mode-selection-screen' establecida a 'flex'.");
        } else {
            console.error("initGlobalDOMReferences: No se pudo encontrar 'mode-selection-screen'.");
        }

        playerInputStrip = document.getElementById('player-input-strip');
        unifiedControlsRow = document.getElementById('unified-controls-row');

        // Adjuntar oyentes de eventos a los campos de entrada de nombre para la tecla Enter.
        const playerNameInputSolo = document.getElementById("player-name");
        if (playerNameInputSolo) {
            safeReattachListener(playerNameInputSolo, 'keydown', (e) => {
                if (e.key === 'Enter') {
                    console.log("Enter key pressed on solo name input.");
                    e.preventDefault();
                    startGame();
                }
            });
            playerNameInputSolo.value = ''; // Limpiar el campo de nombre
        }

        const player1NameInputTwoPlayers = document.getElementById("player1-name-input");
        const player2NameInputTwoPlayers = document.getElementById("player2-name-input");

        if (player1NameInputTwoPlayers) {
            safeReattachListener(player1NameInputTwoPlayers, 'keydown', (e) => {
                if (e.key === 'Enter') {
                    console.log("Enter key pressed on player1 name input.");
                    e.preventDefault();
                    if (player2NameInputTwoPlayers && player2NameInputTwoPlayers.value.trim() === '') {
                        player2NameInputTwoPlayers.focus();
                    } else {
                        startGameTwoPlayers();
                    }
                }
            });
            player1NameInputTwoPlayers.value = ''; // Limpiar el campo de nombre
        }

        if (player2NameInputTwoPlayers) {
            safeReattachListener(player2NameInputTwoPlayers, 'keydown', (e) => {
                if (e.key === 'Enter') {
                    console.log("Enter key pressed on player2 name input.");
                    e.preventDefault();
                    startGameTwoPlayers();
                }
            });
            player2NameInputTwoPlayers.value = ''; // Limpiar el campo de nombre
        }

        // Limpiar el almacenamiento local al inicio para asegurar un estado limpio del juego.
        localStorage.removeItem('gameMode');
        localStorage.removeItem('selectedLevel');
        localStorage.removeItem('playerName1');
        localStorage.removeItem('playerName2');
        localStorage.removeItem('gameMode');
        console.log("initGlobalDOMReferences: localStorage limpiado.");
    }

    // --- Oyentes de Eventos para Carga de Página y Redimensionamiento ---
    document.addEventListener("DOMContentLoaded", () => {
        console.log("DOMContentLoaded disparado.");
        initGlobalDOMReferences(); // Inicializar referencias DOM una vez que el HTML está cargado.

        // Oyente de evento 'resize' para ajustar el juego a cambios en el tamaño de la ventana.
        window.addEventListener("resize", () => {
            console.log("Evento 'resize' detectado.");
            // Resize all animated lines canvases
            resizeAnimatedCanvas(document.getElementById('animatedCanvas'));
            resizeAnimatedCanvas(document.getElementById('animatedCanvasLevel'));
            resizeAnimatedCanvas(document.getElementById('animatedCanvasSoloName'));
            resizeAnimatedCanvas(document.getElementById('animatedCanvasTwoPlayers'));

            // Si la pantalla del juego está activa, pausar, recalcular velocidades y reanudar.
            if (gameScreen && gameScreen.style.display === "flex") { 
                pauseGame(); 
                calculateDynamicSpeedsAndPositions(); 
                updateCSSAnimationsSpeed(); 
                resumeGame(); 
            }
        });

        // Oyentes de teclado globales para el movimiento del coche.
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowLeft') {
                activeKeys.ArrowLeft = true;
                e.preventDefault(); // Prevenir el desplazamiento de la página.
            } else if (e.key === 'ArrowRight') {
                activeKeys.ArrowRight = true;
                e.preventDefault();
            } else if (e.key === 'ArrowUp') {
                activeKeys.ArrowUp = true;
                e.preventDefault();
            } else if (e.key === 'ArrowDown') {
                activeKeys.ArrowDown = true;
                e.preventDefault();
            }
        });

        document.addEventListener('keyup', (e) => {
            if (e.key === 'ArrowLeft') {
                activeKeys.ArrowLeft = false;
            } else if (e.key === 'ArrowRight') {
                activeKeys.ArrowRight = false;
            } else if (e.key === 'ArrowUp') {
                activeKeys.ArrowUp = false;
            } else if (e.key === 'ArrowDown') {
                activeKeys.ArrowDown = false;
            }
        });
        console.log("Oyentes de teclado globales keydown/keyup configurados.");
    });

    // Oyente de evento 'load' para asegurar que todos los recursos (imágenes, etc.) han sido cargados.
    window.addEventListener("load", () => {
        console.log("Ventana cargada (incluyendo recursos externos como imágenes).");
    });

  </script>

</body>
</html>
